<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Pass List — Names & Numbers</title>
  <style>
    :root { 
      --bg:#0c1117; --panel:#0f1621; --muted:#7b869a; --text:#eaf1ff; --border:rgba(255,255,255,0.08); --accent:#60a5fa; --success:#22c55e; --danger:#ef4444; --shadow:0 10px 30px rgba(0,0,0,0.35); --ok:#22c55e; --r:14px; --pad:16px; --gap:16px; --gap-lg:24px; --w-list:70px; --w-name:180px; --w-pass:120px; --table-bg:#0f1621; --thead-bg:rgba(15,22,33,.96); --border-col:rgba(255,255,255,.08);
      
      /* Mobile-specific variables */
      --mobile-touch-target: 44px;
      --mobile-spacing: 12px;
      --mobile-border-radius: 8px;
      --safe-area-top: env(safe-area-inset-top);
      --safe-area-bottom: env(safe-area-inset-bottom);
      --safe-area-left: env(safe-area-inset-left);
      --safe-area-right: env(safe-area-inset-right);
    }
    * { box-sizing: border-box; }
    body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji"; background: var(--bg); color:var(--text); }
    .wrap { max-width: 1200px; margin: 0 auto; padding: var(--gap-lg); }
    .container { max-width: none; width: 100%; margin: 0 auto; padding: 24px; }
    .body-grid { display: block; width: 100%; }
    /* Search panel spans full width */
    .body-grid > .panel:first-child { width: 100%; margin-bottom: 16px; }
    @media (max-width: 1400px){ .body-grid { grid-template-columns: 1fr; } }
    @media (max-width: 1024px){ .body-grid { grid-template-columns: 1fr; } }
    /* Cards occupy full width of their grid column */
    .panel, .card { width: 100%; }
    .table-card, .who-rail { min-width: 0; }
    .table-card { overflow-x: auto; }
    .table-card{ width: 100%; margin-top: 0; display: inline-block; vertical-align: top; }
    .who-rail{ width: 340px; position: fixed; right: 20px; top: 100px; max-height: 80vh; overflow-y: auto; z-index: 50; }
    /* Nuke any rogue max-width/padding on table wrappers */
    .table-card,
    .table-card .table-wrap,
    .table-card .table-inner,
    .table-card .table-content,
    .table-card .table-scroll {
      max-width: none !important;
      margin-right: 0 !important;
      padding-right: 0 !important;
      width: 100% !important;
      overflow-x: auto !important;
    }
    .table-card [style*="calc(100% - 340px)"] { width: 100% !important; }
    .table-card::after,
    .table-card .table-scroll::after,
    .table-card .scrollwrap::after { content: none !important; }
    header.stickybar { position:sticky; top:0; z-index:60; backdrop-filter:saturate(120%) blur(6px); background:linear-gradient(to bottom, rgba(15,22,33,.92), rgba(15,22,33,.82)); border-bottom:1px solid var(--border); padding:10px var(--pad); display:flex; align-items:center; justify-content:space-between; gap:var(--gap); margin:-var(--gap-lg) -var(--gap-lg) var(--gap-lg) -var(--gap-lg); }
    h1 { font-size: 22px; margin: 0; font-weight: 700; letter-spacing: .2px; }
    .tag { font-size:12px; color:var(--muted); }

    .panel { background: var(--panel); border:1px solid var(--border); border-radius: 16px; box-shadow: var(--shadow); }
    .panel + .panel { margin-top: 24px; }
    .panel .head { display:flex; align-items:center; justify-content:space-between; padding: 16px 20px; border-bottom: 1px solid var(--border); }
    .panel .body { padding: 16px 20px; }

    form.inline { display:grid; grid-template-columns: 1fr 1fr auto; gap: 10px; }
    @media (max-width: 720px){ form.inline { grid-template-columns: 1fr; } }
    label { font-size: 12px; color: var(--muted); display:block; margin-bottom:6px; }
    input[type="text"], input[type="number"], input[type="search"] { width:100%; height:40px; padding: 0 12px; border-radius: 12px; border:1px solid var(--border); background: rgba(255,255,255,0.03); color:#e6eefb; outline:none; transition: border-color .15s ease, box-shadow .15s ease; }
    input::placeholder { color:#6b7280; }
    input:focus { outline: 2px solid var(--accent); outline-offset: 2px; box-shadow: 0 0 0 3px rgba(96,165,250,.35); }
    /* Hide number input spinners (Chrome/Edge/Safari) */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    /* Hide number input spinners (Firefox) */
    input[type="number"] { -moz-appearance: textfield; appearance: textfield; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }

    button { cursor:pointer; border:none; border-radius: 12px; padding:8px 14px; font-weight:600; color:var(--text); background: rgba(255,255,255,0.06); border:1px solid var(--border); transition: transform .08s ease, box-shadow .15s ease; }
    button:hover { box-shadow: 0 6px 18px rgba(0,0,0,0.25); transform: translateY(-1px); }
    button.primary { background: var(--success); color:#0b1119; border-color: transparent; }
    button.secondary { background: rgba(255,255,255,0.06); }
    button.ghost { background: transparent; color: var(--muted); }
    button.danger { background: var(--danger); color:white; border-color: transparent; }
    .btn-group { display:flex; gap:8px; justify-content:flex-end; }
    button:disabled { opacity:.6; cursor:not-allowed; }

    table { width: 100%; border-collapse: separate; border-spacing: 0; }
    thead th { text-align:left; font-size:12.5px; color: var(--muted); font-weight:700; letter-spacing:.3px; padding: 10px 12px; user-select: none; border-right: 1px solid rgba(255,255,255,0.06); }
    thead th:last-child { border-right: none; }
    /* Sticky header rows for clarity (below left stickies) */
    thead tr:nth-child(1) th { position: sticky; top: 0; background: var(--thead-bg); z-index: 10; }
    thead tr:nth-child(2) th { position: sticky; top: 44px; background: var(--thead-bg); z-index: 10; }
    /* Headers with sticky-col class get higher z-index */
    thead tr:nth-child(1) th.sticky-col { z-index: 30; }
    thead tr:nth-child(2) th.sticky-col { z-index: 30; }
    thead th.th-group { padding-bottom: 14px; border-bottom: 1px solid var(--border); }
    thead th.th-sub { line-height: 1.1; padding-top: 0; }
    tbody td { padding: 10px 12px; vertical-align: middle; border-right: 1px solid rgba(255,255,255,0.04); }
    tbody td:last-child { border-right: none; }
    /* Allow rows to grow naturally so long names are fully visible */
    tbody tr { height: auto; }
    tfoot td { padding: 10px 8px; font-weight: 700; font-size: 0.95rem; border-top: 1px solid var(--border); }
    tbody tr { transition: background-color 0.15s ease; }
    tbody tr:hover { background: rgba(59,130,246,.08); }
    /* Remove zebra striping for calmer grid */
    th.sortable { cursor: pointer; }
    th.sortable .dir { margin-left:6px; opacity:.7; font-size:11px; }
    .muted { color: var(--muted); }
    .right { text-align:right; }
    /* Sticky left columns */
    thead .sticky-col, tbody .sticky-col, tfoot .sticky-col { position: sticky; background: var(--table-bg); z-index: 20; box-shadow: 1px 0 0 0 var(--border) inset; contain: paint; }
    thead .sticky-col { z-index: 25; contain: paint; background: var(--thead-bg); }
    /* Shorten the main table with an internal scroll area so
       you can always see a subset of rows and horizontally
       scroll to reveal the remaining dates */
    /* Show all names vertically; horizontal scroll for dates; no inner side gutters */
    .scrollwrap { position: relative; overflow-x: auto; overflow-y: visible; width: 100%; margin: 0; }
    /* Table scroll container - allow horizontal scrolling while sticky columns stay fixed */
    .table-scroll { overflow-x: auto; overflow-y: auto; margin: 0; padding: 0; width: 100%; max-height: 75vh; }
    .collapsible[data-collapsed="true"] .body { display:none; }
    .caret { transform: rotate(0deg); transition: transform .15s ease; }
    .collapsible[data-collapsed="true"] .caret { transform: rotate(-90deg); }
    /* Sticky right column (Row Total) */
    .sticky-right-total, .sticky-right-actions{ position: sticky; background: var(--table-bg); box-shadow: -1px 0 0 0 var(--border-col) inset; }
    .sticky-right-actions{ right: 0; z-index: 12; }
    .sticky-right-total{ right: 100px; z-index: 12; }
    thead .sticky-right, tbody .sticky-right, tfoot .sticky-right { position: sticky; right: 0; background: var(--table-bg); z-index: 25; box-shadow: -1px 0 0 0 var(--border) inset; }
    thead .sticky-right { background: var(--thead-bg); }
    /* Pulse highlight for reveal */
    @keyframes pulse-bg { 0% { background: rgba(96,165,250,.25);} 100% { background: transparent; } }
    .pulse { animation: pulse-bg 1.2s ease-out 1; }
    /* Col classes only set width; sticky offsets via nth-child rules */
    .col-list { width: var(--w-list); text-align: center; }
    .col-name { width: var(--w-name); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .col-pass { width: var(--w-pass); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-family: monospace; }
    .num { font-feature-settings: "tnum" 1, "ss01" 1; }
    .ot-table { width: 100%; min-width: 1200px; table-layout: auto; border-collapse: separate; border-spacing: 0; position: relative; }
    .ot-table th, .ot-table td { 
      padding: 10px 12px; 
      vertical-align: middle; 
      white-space: nowrap; 
      overflow: hidden; 
      text-overflow: ellipsis; 
      line-height: 1.25; 
      word-break: normal; 
      writing-mode: horizontal-tb !important; 
      transform: none !important; 
      letter-spacing: normal !important; 
      background-clip: padding-box;
      position: relative;
    }
    .ot-table th, .ot-table td, .name-cell { writing-mode: horizontal-tb !important; transform: none !important; }
    /* Simple column styling without sticky positioning */
    .ot-table tr > *:nth-child(1) { 
      background: var(--table-bg); 
    }
    .ot-table tr > *:nth-child(2) { 
      background: var(--table-bg); 
    }
    .ot-table tr > *:nth-child(3) { 
      background: var(--table-bg); 
      border-right: 2px solid rgba(96,165,250,0.2) !important;
    }
    .day-cell { min-width: 60px; max-width: 80px; }
    .day-cell > input[type="number"]{ width:100%; box-sizing: border-box; }
    /* Colgroup-driven widths (locks predictable sizes) */
    .col-list{ width: var(--w-list); }
    .col-name{ width: var(--w-name); }
    .col-pass{ width: var(--w-pass); }
    .col-total{ width:100px; }
    .col-actions{ width:100px; }
    .shifts > col{ width:80px; }
    .col-shift{ width:80px; }
    /* Header cell stacks without forcing layout weirdness */
    .header-cell{ display:inline-flex; flex-direction:column; align-items:center; gap:2px; }
    .header-cell .dow{ font-size:13px; }
    .header-cell .date{ font-size:11px; opacity:.8; }
    .header-cell .shift-name{ font-size:12px; font-weight:600; }
    .header-cell .shift-time{ font-size:10px; opacity:.8; }
    .day-cell > input[type="number"] {
      box-sizing: border-box;
      height: 40px; /* ~2.5rem */
      font-size: 1rem;
      text-align: center;
      font-variant-numeric: tabular-nums;
      font-feature-settings: "tnum" 1;
      overflow: visible;
      line-height: 1.2;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .day-cell > input[type="number"]:hover {
      background: rgba(255,255,255,0.04);
    }
    .day-cell > input[type="number"]:focus {
      background: rgba(96,165,250,0.1);
    }
    .row-total-input { box-sizing: border-box; min-width: 90px; height: 40px; font-size: 1rem; text-align: right; font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1; }
    td.row-total { background: rgba(255,255,255,.04); border-radius: 12px; }
    @media (max-width: 1200px){
      .who-rail { position: relative; right: auto; top: auto; width: 100%; margin-top: 20px; }
      .table-card { width: 100%; }
    }
    @media (max-width: 800px){
      .ot-table { min-width: 600px; }
      .day-cell { min-width: 50px; max-width: 60px; }
      .col-name { width: 150px; }
      .day-cell > input[type="number"] { height: 48px; font-size: 14px; }
    }
    @media (max-width: 640px){
      .day-cell > input[type="number"] { height: 48px; }
    }
    .pill { font-size: 12px; padding:6px 10px; border:1px solid var(--border); background:rgba(255,255,255,0.03); border-radius: 999px; color: var(--muted); }

    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
    .spacer { flex:1; }
    .sr-only { position:absolute; left:-10000px; width:1px; height:1px; overflow:hidden; }
    /* Who's Next card styles */
    /* Show about 10 items, then allow scrolling for the rest */
    #wnList { max-height: 480px; overflow-y: auto; padding-right: 4px; }
    #wnList .wn-item { display:flex; align-items:center; justify-content:space-between; padding:8px 4px; border-bottom:1px solid var(--border); }
    #wnList .wn-left { display:flex; align-items:flex-start; gap:10px; min-width:0; }
    #wnList .wn-rank { width:28px; text-align:center; }
    /* Allow Who's Next names to wrap onto multiple lines for full visibility */
    #wnList .wn-name { font-weight:600; color:var(--text); white-space:normal; overflow:visible; text-overflow:clip; }
    #wnList .wn-meta { font-size:12px; color:var(--muted); }
    #wnList .wn-right { min-width:80px; text-align:right; font-weight:600; }
    
    /* Who's Next buttons */
    #wnList .wn-buttons { display:flex; gap:4px; margin-top:4px; }
    #wnList .wn-btn { padding:4px 8px; font-size:11px; font-weight:500; border-radius:8px; cursor:pointer; border:none; transition:all .15s ease; }
    #wnList .wn-btn:hover { transform:translateY(-1px); box-shadow:0 2px 8px rgba(0,0,0,0.2); }
    #wnList .wn-btn.not-here { background:var(--muted); color:white; }
    #wnList .wn-btn.not-here:hover { background:#6b7280; }
    
    /* Who's Next shift buttons */
    #wnList .wn-shifts { 
      display: flex; 
      gap: 6px; 
      margin-top: 8px; 
      flex-wrap: wrap; 
      align-items: center;
    }
    #wnList .shift-btn-group { 
      display: flex; 
      align-items: center; 
      gap: 6px; 
      position: relative;
      margin-bottom: 4px;
    }
    #wnList .shift-btn { 
      padding: 6px 10px; 
      font-size: 11px; 
      font-weight: 500; 
      border-radius: 6px; 
      cursor: pointer; 
      border: 1px solid var(--border);
      background: var(--bg); 
      color: var(--text);
      transition: all 0.15s ease;
      position: relative;
    }
    #wnList .shift-btn:hover { 
      background: var(--accent); 
      color: white; 
      border-color: var(--accent);
      transform: translateY(-1px);
    }
    #wnList .shift-btn.shift-full { 
      background: var(--muted); 
      color: white; 
      cursor: not-allowed; 
      opacity: 0.7;
    }
    #wnList .shift-btn.shift-full:hover { 
      transform: none;
      background: var(--muted);
      color: white;
    }
    #wnList .shift-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      background: var(--success);
      color: white;
      border-radius: 8px;
      padding: 1px 4px;
      font-size: 9px;
      font-weight: 600;
      line-height: 1;
      min-width: 12px;
      text-align: center;
    }
    #wnList .refuse-btn { 
      padding: 6px 10px; 
      font-size: 10px; 
      font-weight: 600; 
      border-radius: 5px; 
      cursor: pointer; 
      border: 1px solid var(--danger);
      background: var(--danger); 
      color: white;
      transition: all 0.15s ease;
      white-space: nowrap;
      min-width: 100px;
    }
    #wnList .refuse-btn:hover { 
      background: #dc2626; 
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(220, 38, 38, 0.3);
    }
    #wnList .refuse-btn.disabled { 
      opacity: 0.5; 
      cursor: not-allowed;
    }
    #wnList .refuse-btn.disabled:hover { 
      transform: none;
      background: var(--danger);
      box-shadow: none;
    }
    #wnList .refuse-btn.refused {
      background: #6b7280;
      border-color: #6b7280;
      color: white;
      font-size: 8px;
      cursor: default;
    }
    #wnList .refuse-btn.refused:hover {
      transform: none;
      background: #6b7280;
      box-shadow: none;
    }
    #wnList .refuse-btn.pending {
      background: #f59e0b;
      border-color: #f59e0b;
      cursor: wait;
    }
    
    /* Accept OT button states */
    #wnList .accept-ot-btn { 
      padding: 6px 10px; 
      font-size: 10px; 
      font-weight: 600; 
      border-radius: 5px; 
      cursor: pointer; 
      border: 1px solid var(--success);
      background: var(--success); 
      color: white;
      transition: all 0.15s ease;
      position: relative;
      white-space: nowrap;
      min-width: 100px;
    }
    #wnList .accept-ot-btn:hover { 
      background: #059669; 
      border-color: #059669;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }
    #wnList .accept-ot-btn.accept-ot-assigned { 
      background: #059669; 
      border-color: #059669;
      cursor: default;
    }
    #wnList .accept-ot-btn.accept-ot-assigned:hover { 
      transform: none;
      box-shadow: none;
    }
    #wnList .accept-ot-btn.accept-ot-full,
    #wnList .accept-ot-btn.accept-ot-locked,
    #wnList .accept-ot-btn.accept-ot-blocked,
    #wnList .accept-ot-btn.accept-ot-refused { 
      background: var(--muted); 
      border-color: var(--muted);
      color: white;
      opacity: 0.7;
      cursor: not-allowed; 
    }
    #wnList .accept-ot-btn.accept-ot-full:hover,
    #wnList .accept-ot-btn.accept-ot-locked:hover,
    #wnList .accept-ot-btn.accept-ot-blocked:hover,
    #wnList .accept-ot-btn.accept-ot-refused:hover { 
      transform: none;
      background: var(--muted);
      box-shadow: none;
    }
    #wnList .accept-ot-btn.pending { 
      background: #f59e0b; 
      border-color: #f59e0b;
      cursor: wait;
    }
    #wnList .shifts-empty {
      color: var(--muted);
      font-size: 11px;
      font-style: italic;
      margin-top: 8px;
    }
    
    
    /* Adjust wn-item layout to accommodate buttons */
    #wnList .wn-item { flex-wrap:wrap; }
    #wnList .wn-main { display:flex; align-items:center; justify-content:space-between; width:100%; }
    #wnList .wn-buttons { width:100%; justify-content:flex-end; }
    
    
    /* Shift display styles */
    .shift-cell { 
      position: relative; 
      padding: 4px;
      min-width: 80px;
    }
    .shift-display {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .shift-info {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1px;
    }
    .shift-hours {
      font-weight: bold;
      font-size: 0.95em;
      color: var(--text);
    }
    .shift-time {
      font-size: 0.75em;
      color: var(--muted);
      white-space: nowrap;
    }
    .shift-badge {
      background: var(--accent);
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.7em;
      margin-top: 2px;
      white-space: nowrap;
    }
    .shift-breakdown {
      display: flex;
      gap: 4px;
      margin-top: 2px;
      font-size: 0.7em;
      justify-content: center;
    }
    .regular-hours {
      color: var(--muted);
    }
    .ot-hours {
      color: var(--success);
      font-weight: bold;
    }
    .shift-selector {
      width: 100%;
      font-size: 0.85em;
      padding: 2px;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--text);
    }
    /* Who's Next eligibility styles */
    .wn-item.ineligible {
      opacity: 0.6;
      background: rgba(239, 68, 68, 0.05);
    }
    .ineligible-reason {
      color: var(--danger);
      font-size: 0.75em;
      font-style: italic;
      margin-top: 2px;
    }
    .weekend-hours {
      font-size: 0.85em;
      color: var(--muted);
    }
    
    /* Shift hour input cells */
    .shift-hour-cell {
      padding: 4px;
      text-align: center;
    }
    .shift-hour-cell input[type="number"] {
      width: 100%;
      height: 36px;
      font-size: 14px;
      text-align: center;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.03);
      color: var(--text);
      padding: 0 8px;
    }
    .shift-hour-cell input[type="number"]:focus {
      outline: 2px solid var(--accent);
      outline-offset: 1px;
      box-shadow: 0 0 0 2px rgba(96,165,250,.25);
    }
    
    /* Refusal styling - red text and background for refused hours */
    .shift-hour-cell.refused {
      background: rgba(239, 68, 68, 0.1);
      border-radius: 6px;
    }
    .shift-hour-cell.refused input[type="number"] {
      color: var(--danger);
      background: rgba(239, 68, 68, 0.05);
      border-color: var(--danger);
      font-weight: 600;
    }
    .shift-hour-cell.refused input[type="number"]:focus {
      outline: 2px solid var(--danger);
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.25);
    }
    .shift-hour-cell.refused::after {
      content: 'R';
      position: absolute;
      top: 2px;
      right: 4px;
      font-size: 10px;
      color: var(--danger);
      font-weight: bold;
      pointer-events: none;
    }
    
    /* Refused but worked styling - orange/yellow for disciplinary tracking */
    .shift-hour-cell.refused-worked {
      background: rgba(251, 146, 60, 0.1);
      border-radius: 6px;
    }
    .shift-hour-cell.refused-worked input[type="number"] {
      color: #f59e0b;
      background: rgba(251, 146, 60, 0.05);
      border-color: #f59e0b;
      font-weight: 600;
    }
    .shift-hour-cell.refused-worked input[type="number"]:focus {
      outline: 2px solid #f59e0b;
      box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.25);
    }
    .shift-hour-cell.refused-worked::after {
      content: 'R/W';
      position: absolute;
      top: 2px;
      right: 2px;
      font-size: 9px;
      color: #f59e0b;
      font-weight: bold;
      pointer-events: none;
    }
    
    /* Admin override controls */
    .shift-admin-controls {
      margin-top: 4px;
      display: flex;
      gap: 4px;
      justify-content: center;
    }
    .shift-admin-controls label {
      font-size: 10px;
      display: flex;
      align-items: center;
      gap: 2px;
      color: var(--muted);
      cursor: pointer;
    }
    .shift-admin-controls input[type="checkbox"] {
      width: 12px;
      height: 12px;
    }
    .shift-hour-cell {
      position: relative;
    }
    
    /* Capacity indicators in table headers */
    .capacity-indicator {
      display: block;
      font-size: 10px;
      font-weight: 500;
      color: var(--muted);
      margin-top: 2px;
      padding: 1px 4px;
      border-radius: 3px;
      background: rgba(255,255,255,0.05);
    }
    
    /* Capacity state styling */
    .shift-col.partial .capacity-indicator {
      color: #f59e0b;
      background: rgba(251, 146, 60, 0.1);
    }
    
    .shift-col.full .capacity-indicator {
      color: var(--danger);
      background: rgba(239, 68, 68, 0.1);
      font-weight: 600;
    }
    
    .shift-col.full .capacity-indicator::after {
      content: ' FULL';
      font-size: 8px;
      margin-left: 2px;
    }
    
    /* Weekend Summary Dashboard */
    .weekend-capacity-summary {
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 16px;
    }
    
    .weekend-header {
      margin-bottom: 16px;
    }
    
    .weekend-title {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }
    
    .weekend-title strong {
      font-size: 15px;
      color: var(--text);
    }
    
    .weekend-dates {
      font-size: 12px;
      color: var(--muted);
      background: rgba(255,255,255,0.05);
      padding: 2px 6px;
      border-radius: 4px;
    }
    
    .overall-progress {
      margin-bottom: 0;
    }
    
    .status-header {
      font-size: 13px;
      margin-bottom: 8px;
      font-weight: 600;
      color: var(--text);
    }
    
    .progress-bar-container {
      width: 100%;
    }
    
    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--success), var(--accent));
      transition: width 0.3s ease;
    }
    
    .shift-breakdown {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .shift-status {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 12px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.05);
    }
    
    .shift-status.partial {
      background: rgba(251, 146, 60, 0.08);
      border-color: rgba(251, 146, 60, 0.2);
      color: #f59e0b;
    }
    
    .shift-status.full {
      background: rgba(239, 68, 68, 0.08);
      border-color: rgba(239, 68, 68, 0.2);
      color: var(--danger);
    }
    
    .shift-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .shift-name {
      font-weight: 500;
    }
    
    .full-badge {
      background: var(--danger);
      color: white;
      font-size: 9px;
      font-weight: 700;
      padding: 2px 4px;
      border-radius: 3px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .shift-metrics {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .shift-count {
      font-weight: 600;
      font-size: 11px;
    }
    
    .mini-progress {
      width: 30px;
      height: 4px;
      background: rgba(255,255,255,0.1);
      border-radius: 2px;
      overflow: hidden;
    }
    
    .mini-fill {
      height: 100%;
      background: currentColor;
      transition: width 0.3s ease;
    }
    
    /* Context menu styling */
    .context-menu {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      padding: 4px 0;
      min-width: 150px;
      font-size: 14px;
    }
    .context-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      color: var(--text);
      transition: background-color 0.15s ease;
    }
    .context-menu-item:hover {
      background: rgba(255,255,255,0.08);
    }
    .context-menu-item:first-child {
      border-radius: 6px 6px 0 0;
    }
    .context-menu-item:last-child {
      border-radius: 0 0 6px 6px;
    }
    .not-available {
      font-size: 0.85em;
      color: var(--muted);
      font-style: italic;
    }

    /* --- Row Total: consistent with sticky system --- */
    .ot-table tr > *:nth-last-child(2) {
      /* Total column */
      background: var(--table-bg);
      border-left: 2px solid rgba(96,165,250,0.2) !important;
      text-align: right;
    }
    .ot-table tr > *:nth-last-child(1) {
      /* Actions column */
      background: var(--table-bg);
    }
    /* Header versions get higher z-index */
    thead .ot-table tr > *:nth-last-child(2),
    thead .ot-table tr > *:nth-last-child(1) {
      background: var(--thead-bg);
      z-index: 25;
    }
    /* Row Total input styling */
    .row-total-cell input {
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,.08);
      color: #e6eefb;
      text-align: right;
    }

    /* === MOBILE-FIRST RESPONSIVE STYLES === */
    @media (max-width: 768px) {
      /* Safe area and viewport handling for iOS */
      body {
        padding-top: var(--safe-area-top);
        padding-bottom: var(--safe-area-bottom);
        padding-left: var(--safe-area-left);
        padding-right: var(--safe-area-right);
        min-height: 100svh; /* Use small viewport height to avoid iOS issues */
        /* Prevent bounce scrolling on iOS */
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: none;
        /* Prevent text selection issues on iOS */
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-tap-highlight-color: transparent;
      }

      /* Re-enable text selection for inputs and editable content */
      input, 
      textarea, 
      [contenteditable="true"],
      .selectable {
        -webkit-user-select: text;
        user-select: text;
      }

      /* Prevent iOS zoom on double-tap */
      * {
        touch-action: manipulation;
      }

      /* Allow scrolling for scrollable containers */
      .scrollable,
      #wnList,
      .bottom-sheet,
      .table-card {
        touch-action: pan-y;
        -webkit-overflow-scrolling: touch;
      }

      /* Horizontal scroll containers */
      .ot-table {
        touch-action: pan-x;
        -webkit-overflow-scrolling: touch;
      }
      
      .container {
        padding: var(--mobile-spacing);
      }
      
      .wrap {
        padding: var(--mobile-spacing);
      }

      /* Touch-friendly interactive elements - Apply to ALL buttons */
      button, 
      input[type="button"],
      input[type="submit"],
      .wn-btn,
      .accept-ot-btn,
      .refuse-btn,
      .shift-btn,
      [role="button"] {
        min-height: var(--mobile-touch-target);
        min-width: var(--mobile-touch-target);
        padding: 12px 16px;
        font-size: 14px;
        border-radius: var(--mobile-border-radius);
        /* Remove hover effects on mobile */
        transform: none !important;
        /* Add spacing between buttons for easier tapping */
        margin: 2px;
      }

      /* Special handling for header toolbar buttons */
      .toolbar button {
        margin: 4px 2px;
        font-size: 13px;
      }

      /* Ensure button groups have proper spacing */
      .btn-group {
        gap: var(--mobile-spacing);
        flex-wrap: wrap;
      }

      /* Form buttons get extra spacing */
      form .btn-group button,
      form button {
        margin: 6px 4px;
      }

      /* Better touch targets for inputs */
      input[type="text"], 
      input[type="number"], 
      input[type="search"],
      input[type="file"],
      select,
      textarea {
        min-height: var(--mobile-touch-target);
        font-size: 16px; /* Prevent zoom on iOS */
        padding: 12px 16px;
        margin: 4px 2px;
      }

      /* Touch-friendly clickable areas */
      .sortable,
      [data-action],
      .clickable,
      tr[onclick],
      td[onclick] {
        min-height: var(--mobile-touch-target);
        padding: 12px;
      }

      /* Ensure labels for checkboxes and radios have proper touch area */
      label {
        min-height: var(--mobile-touch-target);
        display: flex;
        align-items: center;
        padding: 8px;
        margin: 4px 0;
      }

      /* Touch-friendly checkbox and radio inputs */
      input[type="checkbox"],
      input[type="radio"] {
        min-width: 20px;
        min-height: 20px;
        margin-right: 12px;
      }

      /* Remove hover effects completely on mobile */
      button:hover,
      .wn-btn:hover,
      .accept-ot-btn:hover,
      .refuse-btn:hover,
      .shift-btn:hover {
        transform: none !important;
        box-shadow: none !important;
      }

      /* Focus states for accessibility */
      button:focus,
      .wn-btn:focus,
      .accept-ot-btn:focus,
      .refuse-btn:focus {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }

      /* Sticky weekend status bar at top on mobile */
      .mobile-weekend-status {
        position: sticky;
        top: var(--safe-area-top, 0);
        z-index: 100;
        background: var(--panel);
        border-bottom: 1px solid var(--border);
        padding: var(--mobile-spacing);
        margin: -var(--mobile-spacing) -var(--mobile-spacing) var(--mobile-spacing) -var(--mobile-spacing);
        backdrop-filter: saturate(120%) blur(6px);
        display: block !important; /* Show on mobile */
      }

      /* Status chips in mobile status bar */
      .status-chip {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        background: var(--bg);
        border: 1px solid var(--border);
        border-radius: 12px;
        font-size: 11px;
        font-weight: 500;
        white-space: nowrap;
      }

      .status-chip.filled {
        background: var(--success);
        color: white;
        border-color: var(--success);
      }

      .status-chip.partial {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }

      .status-chip.empty {
        background: var(--bg);
        color: var(--muted);
        border-color: var(--border);
      }

      /* Mobile Who's Next card layout */
      #wnList .wn-item {
        position: relative;
        flex-direction: column;
        align-items: stretch;
        padding: 16px;
        margin-bottom: 12px;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: var(--mobile-border-radius);
        box-shadow: var(--shadow);
      }

      #wnList .wn-main {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
        padding-right: 32px; /* Space for absolute rank badge */
      }

      #wnList .wn-left {
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
      }

      #wnList .wn-rank {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 24px;
        height: 24px;
        background: var(--accent);
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: 600;
      }

      /* Mobile shift buttons layout */
      #wnList .wn-shifts {
        margin-top: 12px;
      }

      #wnList .shift-btn-group {
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
      }

      #wnList .shift-btn,
      #wnList .accept-ot-btn {
        flex: 1;
        min-width: 120px;
        padding: 12px 16px;
        font-size: 13px;
        border-radius: var(--mobile-border-radius);
      }

      #wnList .refuse-btn {
        min-width: var(--mobile-touch-target);
        padding: 12px;
        margin-left: 8px;
        border-radius: var(--mobile-border-radius);
        font-size: 12px;
        font-weight: 600;
      }

      /* Table improvements for mobile */
      .table-card {
        margin: 0 -var(--mobile-spacing);
        border-radius: 0;
      }

      .ot-table {
        font-size: 14px;
      }

      .day-cell > input[type="number"] {
        height: 42px;
        font-size: 14px;
      }

      /* Better spacing for mobile forms */
      form.inline {
        gap: var(--mobile-spacing);
      }

      .panel .body {
        padding: 16px;
      }

      .panel .head {
        padding: 16px;
      }

      /* Hide elements that don't work well on mobile */
      .who-rail {
        position: static !important;
        width: 100% !important;
        right: auto !important;
        top: auto !important;
        margin-top: 20px;
      }
    }

    /* Hide mobile weekend status on desktop and restore desktop Who's Next layout */
    @media (min-width: 769px) {
      .mobile-weekend-status {
        display: none !important;
      }

      /* Desktop Who's Next layout */
      #wnList .wn-item {
        position: static;
        flex-direction: row;
        padding: 8px 4px;
        margin-bottom: 0;
        background: transparent;
        border: none;
        border-bottom: 1px solid var(--border);
        border-radius: 0;
        box-shadow: none;
      }

      #wnList .wn-main {
        padding-right: 0;
        margin-bottom: 0;
        flex: 1;
      }

      #wnList .wn-left {
        flex-direction: row;
        align-items: flex-start;
        gap: 10px;
      }

      #wnList .wn-rank {
        position: static;
        width: 28px;
        height: auto;
        background: transparent;
        color: var(--text);
        border-radius: 0;
        display: block;
        text-align: center;
        font-size: inherit;
        font-weight: inherit;
      }

      #wnList .wn-buttons {
        width: auto;
        justify-content: flex-start;
      }

      #wnList .wn-shifts {
        margin-top: 4px;
      }

      #wnList .shift-btn-group {
        margin-bottom: 4px;
        flex-wrap: nowrap;
      }

      #wnList .shift-btn,
      #wnList .accept-ot-btn {
        flex: none;
        min-width: auto;
        padding: 6px 10px;
        font-size: 11px;
      }

      #wnList .refuse-btn {
        min-width: auto;
        padding: 6px 10px;
        margin-left: 6px;
        font-size: 11px;
      }
    }

    /* === TOAST NOTIFICATION STYLES === */
    .toast-container {
      position: fixed;
      top: calc(var(--safe-area-top, 0px) + 20px);
      right: calc(var(--safe-area-right, 0px) + 20px);
      z-index: 1000;
      pointer-events: none;
    }

    .toast {
      background: var(--panel);
      color: var(--text);
      padding: 12px 16px;
      border-radius: var(--mobile-border-radius);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      margin-bottom: 8px;
      opacity: 0;
      transform: translateX(100%);
      transition: all 0.3s ease;
      pointer-events: auto;
      font-size: 14px;
      max-width: 280px;
    }

    .toast.show {
      opacity: 1;
      transform: translateX(0);
    }

    .toast.success {
      border-left: 4px solid var(--success);
    }

    .toast.error {
      border-left: 4px solid var(--danger);
    }

    /* === BOTTOM SHEET MODAL STYLES === */
    .bottom-sheet {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--panel);
      border-top: 1px solid var(--border);
      border-radius: 16px 16px 0 0;
      z-index: 1000;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      box-shadow: 0 -10px 30px rgba(0,0,0,0.5);
      padding-bottom: calc(var(--safe-area-bottom, 0px) + 20px);
      max-height: 80svh;
      overflow-y: auto;
    }

    .bottom-sheet.show {
      transform: translateY(0);
    }

    .bottom-sheet-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 999;
      opacity: 0;
      transition: opacity 0.3s ease;
      backdrop-filter: blur(4px);
    }

    .bottom-sheet-backdrop.show {
      opacity: 1;
    }

    .bottom-sheet-header {
      padding: 20px;
      border-bottom: 1px solid var(--border);
      text-align: center;
      position: relative;
    }

    .bottom-sheet-handle {
      width: 40px;
      height: 4px;
      background: var(--muted);
      border-radius: 2px;
      margin: 0 auto 16px;
    }

    .bottom-sheet-title {
      font-size: 18px;
      font-weight: 600;
      margin: 0;
    }

    .bottom-sheet-close {
      position: absolute;
      top: 16px;
      right: 16px;
      background: none;
      border: none;
      font-size: 24px;
      color: var(--muted);
      cursor: pointer;
      padding: 4px;
      line-height: 1;
    }

    .bottom-sheet-body {
      padding: 20px;
    }

    .bottom-sheet-actions {
      padding: 0 20px 20px;
      display: flex;
      gap: 12px;
    }

    .bottom-sheet-actions button {
      flex: 1;
      min-height: var(--mobile-touch-target);
    }
  </style>
  <meta name="color-scheme" content="dark light" />
  <meta name="description" content="Local page to track names with list # and pass #. Stored in your browser only." />
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1 style="margin:0; font-size:18px; font-weight:600;">Pass List</h1>
        <div class="tag">Offline • Stores data in your browser</div>
      </div>
      <div class="toolbar" style="gap:8px;">
        <button id="exportCsvBtn" class="primary" title="Download as CSV">Export CSV</button>
        <button id="exportJsonBtn" class="secondary" title="Download as JSON">Export JSON</button>
        <button id="importTextBtn" class="ghost" title="Import CSV or JSON">Import</button>
        <button id="migrateHoursBtn" class="secondary" title="Migrate old date-based hours to new shift columns">Migrate Hours</button>
        <button id="seedDemoBtn" class="ghost" title="Add 25 demo rows with fake hours">Demo Data</button>
        <button id="resetAllBtn" class="danger" title="Reset everything including corrupted data">Reset All</button>
        <input id="importFile" class="sr-only" type="file" accept=".csv,.json,text/csv,application/json" />
      </div>
    </header>

    <!-- Mobile sticky weekend status bar -->
    <div id="mobileWeekendStatus" class="mobile-weekend-status" style="display: none;">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
        <div style="font-weight: 600; font-size: 14px;">Weekend Status</div>
        <div id="mobileWeekendDates" style="font-size: 12px; color: var(--muted);"></div>
      </div>
      <div id="mobileStatusChips" style="display: flex; flex-wrap: wrap; gap: 6px;"></div>
    </div>

    <!-- Weekend Dates panel removed per request: this was a read-only visual summary -->

    <section id="entryCard" class="panel collapsible" data-collapsed="false">
      <div class="head"><strong style="font-size:16px;">Add / Edit Entry</strong><span class="pill" id="countPill">0 entries</span>
        <button id="entryToggle" class="ghost" title="Collapse/Expand" style="margin-left:auto;">
          <span class="caret">▾</span>
        </button>
      </div>
      <div class="body">
        <form id="entryForm" class="inline">
          <div>
            <label for="name">Full Name</label>
            <input id="name" name="name" type="text" placeholder="e.g., Jane Doe" autocomplete="off" required />
          </div>
          <div>
            <label for="lisNumber">List # <span class="muted">(optional)</span></label>
            <input id="lisNumber" name="lisNumber" type="text" placeholder="e.g., 8891" autocomplete="off" />
          </div>
          <div>
            <label for="initialHours">Hours <span class="muted">(optional)</span></label>
            <input id="initialHours" name="initialHours" type="number" inputmode="decimal" min="0" max="1000" step="0.25" placeholder="e.g., 25.5" autocomplete="off" />
          </div>
          <div class="row">
            <button type="submit" class="primary" id="saveBtn">Add</button>
            <button type="button" class="ghost" id="cancelEditBtn" style="display:none;">Cancel</button>
          </div>
        </form>
      </div>
    </section>

    <div class="body-grid">
    <!-- Search row as its own card above the table within the grid -->
    <section class="panel">
      <div class="body">
        <input id="search" type="search" placeholder="Search name, list #, or pass #…" aria-label="Search" />
      </div>
    </section>
    
    <!-- Location Configuration Panel -->
    <section class="panel" id="locationConfigPanel">
      <div class="head">
        <strong>Location Settings</strong>
        <span class="pill">Multi-Location Support</span>
      </div>
      <div class="body">
        <div class="row" style="margin-bottom: 12px;">
          <label style="flex: 1;">
            <span style="display: block; margin-bottom: 4px; font-weight: 600;">Number of Locations:</span>
            <input 
              id="locationCountInput" 
              type="number" 
              min="1" 
              max="10" 
              value="1" 
              style="width: 80px; margin-right: 12px;"
              title="Each shift requires 2 people per location"
            />
            <button id="updateLocationBtn" class="primary" style="padding: 6px 12px;">Update</button>
          </label>
        </div>
        <div class="location-capacity-info" style="font-size: 13px; color: var(--muted);">
          <div style="margin-bottom: 4px;">
            <strong>Capacity per shift:</strong> <span id="shiftCapacity">2 people</span> (1 location × 2 people)
          </div>
          <div style="margin-bottom: 4px;">
            <strong>Total weekend capacity:</strong> <span id="totalCapacity">10 people</span> (5 shifts × 1 location × 2 people)
          </div>
          <div style="font-style: italic; color: var(--muted);">
            Each shift requires exactly 2 people to work it. Increase locations to allow more people per shift.
          </div>
        </div>
      </div>
    </section>
    
    <section class="panel table-card">
      <div class="head toolbar">
        <div class="spacer"></div>
        <div class="toolbar">
          <label class="pill" title="Select month to show Fri–Mon weekends">
            <span class="muted">Month</span>
            <input id="monthPicker" type="month" style="margin-left:8px; background:transparent; color:var(--text); border:none; outline:none; height:32px;" />
          </label>
          <span class="pill" id="tableMonthPill"></span>
          <label class="pill" title="Admin mode (visual)">
            <input id="adminSwitch" type="checkbox" disabled />
            <span style="margin-left:6px;">Admin</span>
          </label>
          <button id="clearAllBtn" class="danger" title="Remove all entries">Clear All</button>
        </div>
      </div>
      <div class="body table-wrap">
        <div class="scrollwrap table-scroll">
          <div id="totalHelp" class="sr-only">Edit the cumulative total hours (across all months) to add an adjustment. The system will automatically calculate the adjustment needed.</div>
          <table id="table" class="ot-table">
          <thead id="thead"></thead>
           <tbody id="tbody">
             <!-- rows render here -->
           </tbody>
           <tfoot id="tfoot"></tfoot>
            </table>
          </div>
      </div>
    </section>
    
    <!-- Who's Next panel: positioned under the main table -->
    <section class="panel card who-card" id="whosNextPanel">
      <div class="head">
        <strong>Who's Next</strong>
        <span class="pill" id="wnMonthPill"></span>
      </div>
      <div class="body">
        <div id="weekendSummary" style="margin-bottom: 16px;"></div>
        <div class="row" style="width:100%; margin-bottom:8px;">
          <input id="wnSearch" type="search" placeholder="Filter by name, list #, pass #" aria-label="Filter Who's Next" />
        </div>
        <div id="wnList" aria-live="polite"></div>
        <div class="muted" style="margin-top:8px; font-size:12px;">Reflects live totals. Edit hours in the main table.</div>
      </div>
    </section>

    </div>

    <footer class="row" style="justify-content: space-between; margin-top: 16px; color:var(--muted);">
      <div>Tip: Click headers to sort. Data never leaves your device.</div>
      <div class="pill">v1</div>
    </footer>
  </div>

  <script>
    const STORAGE_KEY = 'pass-list-entries-v1';
    const HOURS_KEY = 'pass-list-hours-v1';
    const ADJ_KEY = 'ot_adjustments_v1'; // manual additive hours per person
    const EXCLUDED_KEY = 'wn_excluded_v1'; // weekend-specific exclusions for Who's Next
    const SHIFTS_KEY = 'pass-list-shifts-v1'; // shift assignments per weekend
    const REFUSALS_KEY = 'shift_refusals_v1'; // shift refusals with work status tracking
    const LOCATION_CONFIG_KEY = 'location_config_v1'; // location configuration settings
    
    // Multi-location constants
    const PEOPLE_PER_SHIFT = 2; // Each shift requires 2 people to work it
    const DEFAULT_LOCATION_COUNT = 1; // Default to single location for backward compatibility
    
    // Event system for click-to-assign functionality
    const ASSIGNMENT_EVENTS_KEY = 'assignment_events_v1';
    
    // Event Types
    const EVENT_TYPES = {
      ASSIGNMENT: 'assignment',
      REFUSAL: 'refusal',
      MANUAL_HOURS: 'manual_hours',
      ADJUSTMENT: 'adjustment'
    };
    
    // Event factory functions
    function createAssignmentEvent(personId, weekendKey, dateKey, shiftId, locationId = 'loc_1', hours = 8) {
      return {
        id: uid(),
        type: EVENT_TYPES.ASSIGNMENT,
        personId,
        weekendKey,
        dateKey,
        shiftId,
        locationId,
        hours,
        timestamp: new Date().toISOString(),
        metadata: {
          shiftLabel: SHIFT_DEFINITIONS[shiftId]?.shortDisplay || shiftId,
          locationLabel: `Location ${locationId}`,
          renderedAtTs: Date.now()
        }
      };
    }
    
    function createRefusalEvent(personId, weekendKey, dateKey, shiftId, locationId = 'loc_1', hours = 8) {
      return {
        id: uid(),
        type: EVENT_TYPES.REFUSAL,
        personId,
        weekendKey,
        dateKey,
        shiftId,
        locationId,
        hours,
        timestamp: new Date().toISOString(),
        metadata: {
          shiftLabel: SHIFT_DEFINITIONS[shiftId]?.shortDisplay || shiftId,
          locationLabel: `Location ${locationId}`,
          renderedAtTs: Date.now()
        }
      };
    }
    
    // Date mapping helper functions (bulletproof date calculation)
    function calculateShiftDateKey(shiftId, weekendKey) {
      const shift = SHIFT_DEFINITIONS[shiftId];
      if (!shift) throw new Error(`Unknown shift ID: ${shiftId}`);
      
      const weekendFriday = new Date(weekendKey + 'T00:00:00');
      const dayOffsets = { 'fri': 0, 'sat': 1, 'sun': 2, 'mon': 3 };
      const startDate = new Date(weekendFriday);
      startDate.setDate(startDate.getDate() + dayOffsets[shift.startDay]);
      
      return dateKey(startDate); // Returns YYYY-MM-DD format
    }
    
    function calculateShiftTimestamps(shiftId, weekendKey) {
      const shift = SHIFT_DEFINITIONS[shiftId];
      if (!shift) throw new Error(`Unknown shift ID: ${shiftId}`);
      
      const weekendFriday = new Date(weekendKey + 'T00:00:00');
      const dayOffsets = { 'fri': 0, 'sat': 1, 'sun': 2, 'mon': 3 };
      
      const startDate = new Date(weekendFriday);
      startDate.setDate(startDate.getDate() + dayOffsets[shift.startDay]);
      const [startHour, startMin] = shift.startTime.split(':').map(Number);
      startDate.setHours(startHour, startMin, 0, 0);
      
      const endDate = new Date(weekendFriday);
      endDate.setDate(endDate.getDate() + dayOffsets[shift.endDay]);
      const [endHour, endMin] = shift.endTime.split(':').map(Number);
      endDate.setHours(endHour, endMin, 0, 0);
      
      return {
        startTs: startDate.toISOString(),
        endTs: endDate.toISOString(),
        dateKey: dateKey(startDate)
      };
    }
    
    // State change broadcasting system for real-time updates
    const stateListeners = new Set();
    
    function subscribeToStateChanges(callback) {
      stateListeners.add(callback);
      return () => stateListeners.delete(callback); // Return unsubscribe function
    }
    
    function broadcastStateChange(changeType, data = {}) {
      console.log(`📡 Broadcasting state change: ${changeType}`, data);
      stateListeners.forEach(listener => {
        try {
          listener(changeType, data);
        } catch (error) {
          console.error('State listener error:', error);
        }
      });
    }
    
    // Event persistence system
    function loadAssignmentEvents() {
      try {
        const stored = localStorage.getItem(ASSIGNMENT_EVENTS_KEY);
        return stored ? JSON.parse(stored) : [];
      } catch (_) { 
        return []; 
      }
    }
    
    function saveAssignmentEvent(event) {
      try {
        const events = loadAssignmentEvents();
        events.push(event);
        localStorage.setItem(ASSIGNMENT_EVENTS_KEY, JSON.stringify(events));
        broadcastStateChange('EVENT_CREATED', { event });
        return event;
      } catch (error) {
        console.error('Failed to save assignment event:', error);
        return null;
      }
    }
    
    // ShiftChip component architecture
    function createShiftChip(personId, shiftId, weekendKey, locationId = 'loc_1', actionType = 'assignment') {
      const shift = SHIFT_DEFINITIONS[shiftId];
      if (!shift) throw new Error(`Unknown shift ID: ${shiftId}`);
      
      const timestamps = calculateShiftTimestamps(shiftId, weekendKey);
      const eligibility = canWorkShift(personId, shiftId, weekendKey);
      const capacity = getShiftCapacity(shiftId);
      const assigned = getShiftAssignedCount(shiftId, weekendKey);
      const hasCapacity = assigned < capacity;
      
      return {
        // Identity & context
        personId,
        weekendKey,
        dateKey: timestamps.dateKey,
        renderedAtTs: Date.now(),
        
        // Shift detail
        shiftId,
        shiftLabel: shift.shortDisplay,
        startTs: timestamps.startTs,
        endTs: timestamps.endTs,
        hours: shift.chargeableHours,
        
        // Location / capacity
        locationId,
        locationLabel: `Location ${locationId}`,
        slotRef: { weekendKey, dateKey: timestamps.dateKey, shiftId, locationId },
        
        // Eligibility (precomputed)
        eligible: eligibility.eligible && hasCapacity,
        eligibilityReason: !eligibility.eligible ? eligibility.reason : 
                          !hasCapacity ? `Shift full (${assigned}/${capacity})` : 'Available',
        lastWorkedEndTs: getLastWorkedTourEndTime(personId, timestamps.startTs, weekendKey),
        
        // Action type
        defaultAction: actionType, // 'assignment' or 'refusal'
        
        // UI metadata
        cssClass: eligibility.eligible && hasCapacity ? 'chip-available' : 'chip-disabled',
        title: eligibility.eligible && hasCapacity ? 
               `Assign ${shift.shortDisplay} (${shift.chargeableHours}h)` :
               eligibility.reason || `No capacity (${assigned}/${capacity})`
      };
    }
    
    // Generate all eligible shift chips for a person (multi-location + eligibility engine)
    
    // === COMPREHENSIVE ELIGIBILITY ENGINE ===
    // Pre-compute all eligibility data for fast UI rendering
    
    function createEligibilitySnapshot(weekendKey = getCurrentWeekendKey()) {
      console.log('🔍 Creating eligibility snapshot for weekend:', weekendKey);
      
      const snapshot = {
        weekendKey,
        timestamp: Date.now(),
        people: {},
        shifts: {},
        capacity: {
          total: getTotalWeekendCapacity(),
          assigned: getTotalAssignedPeople(weekendKey)
        }
      };
      
      // Pre-compute shift capacity and assignment data
      Object.keys(SHIFT_DEFINITIONS).forEach(shiftId => {
        snapshot.shifts[shiftId] = {
          capacity: getShiftCapacity(shiftId),
          assigned: getShiftAssignedCount(shiftId, weekendKey),
          isFull: isShiftAtCapacity(shiftId, weekendKey),
          definition: SHIFT_DEFINITIONS[shiftId]
        };
      });
      
      // Pre-compute eligibility for each person
      state.items.forEach(person => {
        const personId = person.id;
        const personEligibility = {
          id: personId,
          name: person.name,
          excluded: isPersonExcluded(personId, weekendKey),
          currentShifts: getPersonShifts(personId, weekendKey),
          eligibleShifts: {},
          availableChips: []
        };
        
        // Check eligibility for each shift
        Object.keys(SHIFT_DEFINITIONS).forEach(shiftId => {
          const eligibility = canWorkShift(personId, shiftId, weekendKey);
          const isRefused = isShiftRefused(personId, shiftId, weekendKey);
          const shiftData = snapshot.shifts[shiftId];
          
          personEligibility.eligibleShifts[shiftId] = {
            eligible: eligibility.eligible && !personEligibility.excluded && !shiftData.isFull,
            reason: personEligibility.excluded 
              ? 'Excluded for this weekend'
              : shiftData.isFull 
                ? 'Shift at full capacity'
                : eligibility.reason || 'Eligible',
            refused: isRefused,
            hasCapacity: !shiftData.isFull,
            capacity: shiftData.capacity,
            assigned: shiftData.assigned
          };
        });
        
        snapshot.people[personId] = personEligibility;
      });
      
      console.log(`✅ Eligibility snapshot complete: ${Object.keys(snapshot.people).length} people, ${Object.keys(snapshot.shifts).length} shifts`);
      return snapshot;
    }
    
    // Cache the eligibility snapshot for performance
    let eligibilityCache = null;
    let eligibilityCacheTime = 0;
    const ELIGIBILITY_CACHE_TTL = 30000; // 30 seconds
    
    function getEligibilitySnapshot(weekendKey = getCurrentWeekendKey(), forceRefresh = false) {
      const now = Date.now();
      
      if (!forceRefresh && eligibilityCache && 
          eligibilityCache.weekendKey === weekendKey &&
          (now - eligibilityCacheTime) < ELIGIBILITY_CACHE_TTL) {
        return eligibilityCache;
      }
      
      eligibilityCache = createEligibilitySnapshot(weekendKey);
      eligibilityCacheTime = now;
      return eligibilityCache;
    }
    
    // Invalidate eligibility cache when data changes
    function invalidateEligibilityCache() {
      console.log('🗑️ Invalidating eligibility cache');
      eligibilityCache = null;
      eligibilityCacheTime = 0;
    }
    
    
    // Render shift chips for a person (for Who's Next panel)
    
    
    // MTA Overtime Weekend Shift Definitions
    const SHIFT_DEFINITIONS = {
      'shift1_fri_sat': {
        code: 'shift1_fri_sat',
        name: 'Shift 1: Fri-Sat',
        display: '10p-2p',
        shortDisplay: 'Fri 10p-Sat 2p',
        startDay: 'fri', startTime: '22:00',
        endDay: 'sat', endTime: '14:00',
        totalHours: 16,
        regularHours: 8,      // First 8 hours (10pm-6am) - regular time
        overtimeHours: 8,     // Last 8 hours (6am-2pm) - overtime
        chargeableHours: 8,   // Only overtime is chargeable
        sequence: 1
      },
      'shift2_sat_afternoon': {
        code: 'shift2_sat_afternoon',
        name: 'Shift 2: Sat Afternoon',
        display: '2p-10p',
        shortDisplay: 'Sat 2p-10p',
        startDay: 'sat', startTime: '14:00',
        endDay: 'sat', endTime: '22:00',
        totalHours: 8,
        regularHours: 0,      // All overtime
        overtimeHours: 8,     
        chargeableHours: 8,   // All chargeable
        sequence: 2
      },
      'shift3_sat_night': {
        code: 'shift3_sat_night',
        name: 'Shift 3: Sat Night',
        display: '10p-6a',
        shortDisplay: 'Sat 10p-Sun 6a',
        startDay: 'sat', startTime: '22:00',
        endDay: 'sun', endTime: '06:00',
        totalHours: 8,
        regularHours: 0,      // All overtime
        overtimeHours: 8,     
        chargeableHours: 8,   // All chargeable
        sequence: 3
      },
      'shift4_sun_morning': {
        code: 'shift4_sun_morning',
        name: 'Shift 4: Sun Morning',
        display: '6a-2p',
        shortDisplay: 'Sun 6a-2p',
        startDay: 'sun', startTime: '06:00',
        endDay: 'sun', endTime: '14:00',
        totalHours: 8,
        regularHours: 0,      // All overtime
        overtimeHours: 8,     
        chargeableHours: 8,   // All chargeable
        sequence: 4
      },
      'shift5_2_to_finish': {
        code: 'shift5_2_to_finish',
        name: 'Shift 5: 2 to Finish',
        display: '2p-Mon 6a',
        shortDisplay: '2 to Finish',
        startDay: 'sun', startTime: '14:00',
        endDay: 'mon', endTime: '06:00',
        totalHours: 16,
        regularHours: 0,      // All overtime
        overtimeHours: 16,    // All 16 hours
        chargeableHours: 16,  // All chargeable
        sequence: 5,
        special: true         // Special "2 to finish" designation
      }
    };
    const IS_ADMIN = true; // Set to false for read-only mode
    const state = {
      items: [],
      editingId: null,
      filter: '',
      sort: { key: 'lisNumber', dir: 'asc' }, // default: lowest list # at top
      hours: {}, // HoursStore: { [personId]: { [YYYY-MM-DD]: number } }
      adj: {},   // AdjustmentsStore: { [personId]: number }
      excluded: {}, // ExclusionStore: { [weekendKey]: { [personId]: 'done' | 'nothere' } }
      shifts: {}, // ShiftStore: { [weekendKey]: { [personId]: { shifts: [...], lastShiftEnd: datetime } } }
      refusals: {}, // RefusalStore: { [weekendKey]: { [personId]: { [shiftCode]: { refused: boolean, worked: boolean, timestamp: date, actualHours?: number } } } }
      locationCount: DEFAULT_LOCATION_COUNT, // Number of locations (configurable by admin)
      viewYear: new Date().getFullYear(),
      viewMonth1: new Date().getMonth() + 1, // 1-based
      wnQuery: '', // Who's Next filter query
      useRankOrder: false, // table uses explicit sort (List # asc) by default
    };

    const el = {
      form: document.getElementById('entryForm'),
      name: document.getElementById('name'),
      lisNumber: document.getElementById('lisNumber'),
      initialHours: document.getElementById('initialHours'),
      saveBtn: document.getElementById('saveBtn'),
      cancelEditBtn: document.getElementById('cancelEditBtn'),
      search: document.getElementById('search'),
      tbody: document.getElementById('tbody'),
      table: document.getElementById('table'),
      thead: document.getElementById('thead'),
      tfoot: document.getElementById('tfoot'),
      countPill: document.getElementById('countPill'),
      clearAll: document.getElementById('clearAllBtn'),
      exportCsv: document.getElementById('exportCsvBtn'),
      exportJson: document.getElementById('exportJsonBtn'),
      importFile: document.getElementById('importFile'),
      importTextBtn: document.getElementById('importTextBtn'),
      migrateHoursBtn: document.getElementById('migrateHoursBtn'),
      seedDemoBtn: document.getElementById('seedDemoBtn'),
      // Weekend Dates panel removed
      monthPicker: document.getElementById('monthPicker'),
      modePill: document.getElementById('modePill'),
      adminSwitch: document.getElementById('adminSwitch'),
      entryCard: document.getElementById('entryCard'),
      entryToggle: document.getElementById('entryToggle'),
      wnMonthPill: document.getElementById('wnMonthPill'),
      wnSearch: document.getElementById('wnSearch'),
      wnList: document.getElementById('wnList'),
      weekendSummary: document.getElementById('weekendSummary'),
      // Location configuration elements
      locationCountInput: document.getElementById('locationCountInput'),
      updateLocationBtn: document.getElementById('updateLocationBtn'),
      shiftCapacity: document.getElementById('shiftCapacity'),
      totalCapacity: document.getElementById('totalCapacity'),
    };

    function uid(){ return (Date.now().toString(36) + Math.random().toString(36).slice(2,8)).toUpperCase(); }

    function load(){
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) {
          // Validate and clean data
          return arr.filter(x => {
            if (!x || typeof x !== 'object') return false;
            // Ensure required fields exist and are strings
            if (typeof x.name !== 'string' || !x.name.trim()) return false;
            // Don't allow date strings in list number field
            if (x.lisNumber && typeof x.lisNumber === 'string') {
              const lower = x.lisNumber.toLowerCase();
              if (lower.includes('fri') || lower.includes('sat') || lower.includes('sun') || 
                  lower.includes('mon') || lower.includes('sep') || lower.includes('oct') || 
                  lower.includes('nov') || lower.includes('dec') || lower.includes('jan') || 
                  lower.includes('feb') || lower.includes('mar') || lower.includes('apr') || 
                  lower.includes('may') || lower.includes('jun') || lower.includes('jul') || 
                  lower.includes('aug')) {
                console.warn('Filtering out corrupted entry with date in lisNumber:', x);
                return false;
              }
            }
            // Don't allow pure numbers as names
            if (/^\d+$/.test(x.name.trim())) {
              console.warn('Filtering out corrupted entry with number as name:', x);
              return false;
            }
            return true;
          });
        }
      } catch(e) { console.warn('Failed to load saved data', e); }
      return [];
    }

    function save(){
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state.items)); }
      catch(e){ alert('Could not save to local storage.'); console.error(e); }
    }

    function loadHours(){
      try { return JSON.parse(localStorage.getItem(HOURS_KEY) || '{}') || {}; }
      catch(_) { return {}; }
    }
    function saveHours(){
      try { localStorage.setItem(HOURS_KEY, JSON.stringify(state.hours)); } catch(_) {}
    }
    // Adjustments: load/save per-person manual additive hours
    function loadAdj(){
      try {
        // Migrate from legacy key if present
        const legacy = localStorage.getItem('pass-list-extra-hours-v1');
        const current = localStorage.getItem(ADJ_KEY);
        if (current) return JSON.parse(current) || {};
        if (legacy) return JSON.parse(legacy) || {};
        return {};
      } catch(_) { return {}; }
    }
    function saveAdj(){
      try { localStorage.setItem(ADJ_KEY, JSON.stringify(state.adj)); } catch(_) {}
    }

    // === Exclusion Storage System ===
    // Load weekend-specific exclusions: { [weekendKey]: { [personId]: 'done' | 'nothere' } }
    function loadExclusions(){
      try { 
        const stored = localStorage.getItem(EXCLUDED_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch(_) { return {}; }
    }
    
    function saveExclusions(){
      try { localStorage.setItem(EXCLUDED_KEY, JSON.stringify(state.excluded)); } catch(_) {}
    }

    // Check if a person is excluded for the current weekend
    function isPersonExcluded(personId, weekendKey = getCurrentWeekendKey()){
      return !!(state.excluded[weekendKey] && state.excluded[weekendKey][personId]);
    }

    // Exclude a person for the current weekend
    function excludePerson(personId, reason, weekendKey = getCurrentWeekendKey()){
      if (!state.excluded[weekendKey]) state.excluded[weekendKey] = {};
      state.excluded[weekendKey][personId] = reason; // 'done' or 'nothere'
      saveExclusions();
      
      // Invalidate eligibility cache after exclusion
      invalidateEligibilityCache();
      
      // Trigger instant UI updates
      broadcastStateChange('PERSON_EXCLUDED', {
        personId,
        weekendKey,
        reason,
        excluded: true
      });
      
      renderWhosNext(); // Update the display immediately
    }

    // Remove exclusion for a person (for manual reset if needed)
    function includePersonBack(personId, weekendKey = getCurrentWeekendKey()){
      if (state.excluded[weekendKey] && state.excluded[weekendKey][personId]) {
        delete state.excluded[weekendKey][personId];
        // Clean up empty weekend objects
        if (Object.keys(state.excluded[weekendKey]).length === 0) {
          delete state.excluded[weekendKey];
        }
        saveExclusions();
        
        // Invalidate eligibility cache after inclusion
        invalidateEligibilityCache();
        
        // Trigger instant UI updates
        broadcastStateChange('PERSON_EXCLUDED', {
          personId,
          weekendKey,
          reason: null,
          excluded: false
        });
        
        renderWhosNext();
      }
    }

    // Clear all exclusions for old weekends (keep only current and future)
    function cleanupOldExclusions(){
      const currentKey = getCurrentWeekendKey();
      const currentDate = new Date(currentKey);
      const cutoffDate = new Date(currentDate);
      cutoffDate.setDate(cutoffDate.getDate() - 7); // Keep exclusions for past week too
      
      let changed = false;
      Object.keys(state.excluded).forEach(weekendKey => {
        const weekendDate = new Date(weekendKey);
        if (weekendDate < cutoffDate) {
          delete state.excluded[weekendKey];
          changed = true;
        }
      });
      
      if (changed) {
        saveExclusions();
      }
    }

    // === Refusal Storage System ===
    // Load shift refusals: { [weekendKey]: { [personId]: { [shiftCode]: { refused: boolean, worked: boolean, timestamp: date, actualHours?: number } } } }
    function loadRefusals(){
      try { 
        const stored = localStorage.getItem(REFUSALS_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch(_) { return {}; }
    }
    
    function saveRefusals(){
      try { localStorage.setItem(REFUSALS_KEY, JSON.stringify(state.refusals)); } catch(_) {}
    }
    
    // Check if a person refused a specific shift
    function isShiftRefused(personId, shiftCode, weekendKey = getCurrentWeekendKey()){
      return !!(state.refusals[weekendKey] && 
                state.refusals[weekendKey][personId] && 
                state.refusals[weekendKey][personId][shiftCode] &&
                state.refusals[weekendKey][personId][shiftCode].refused);
    }
    
    // Check if a person worked a refused shift (admin override)
    function didWorkRefusedShift(personId, shiftCode, weekendKey = getCurrentWeekendKey()){
      return !!(state.refusals[weekendKey] && 
                state.refusals[weekendKey][personId] && 
                state.refusals[weekendKey][personId][shiftCode] &&
                state.refusals[weekendKey][personId][shiftCode].refused &&
                state.refusals[weekendKey][personId][shiftCode].worked);
    }
    
    // Refuse a shift for a person
    function refuseShift(personId, shiftCode, weekendKey = getCurrentWeekendKey()){
      // If person was already assigned to this shift, remove the assignment first
      const personShifts = state.shifts[weekendKey]?.[personId];
      if (personShifts) {
        const assignedShift = personShifts.shifts.find(s => s.shiftCode === shiftCode);
        if (assignedShift) {
          // Remove the shift assignment (this will also remove hours via removeShift function)
          removeShift(personId, shiftCode, weekendKey);
        }
      }
      
      if (!state.refusals[weekendKey]) state.refusals[weekendKey] = {};
      if (!state.refusals[weekendKey][personId]) state.refusals[weekendKey][personId] = {};
      
      state.refusals[weekendKey][personId][shiftCode] = {
        refused: true,
        worked: false,
        timestamp: new Date().toISOString(),
        actualHours: 0
      };
      
      saveRefusals();
      
      // Invalidate eligibility cache after refusal
      invalidateEligibilityCache();
      
      renderWhosNext(); // Update the display immediately
    }
    
    // Un-refuse a shift (allow person to be assigned again)
    function unrefuseShift(personId, shiftCode, weekendKey = getCurrentWeekendKey()){
      if (state.refusals[weekendKey] && 
          state.refusals[weekendKey][personId] && 
          state.refusals[weekendKey][personId][shiftCode]) {
        delete state.refusals[weekendKey][personId][shiftCode];
        
        // Clean up empty objects
        if (Object.keys(state.refusals[weekendKey][personId]).length === 0) {
          delete state.refusals[weekendKey][personId];
        }
        if (state.refusals[weekendKey] && Object.keys(state.refusals[weekendKey]).length === 0) {
          delete state.refusals[weekendKey];
        }
        
        saveRefusals();
        renderWhosNext();
      }
    }
    
    // Reset a person's shift completely - removes assignments, refusals, and hours
    function resetPersonShift(personId, shiftCode, weekendKey = getCurrentWeekendKey()){
      let actionsPerformed = [];
      
      // Check if person is assigned to this shift
      const personShifts = state.shifts[weekendKey]?.[personId];
      if (personShifts) {
        const assignedShift = personShifts.shifts.find(s => s.shiftCode === shiftCode);
        if (assignedShift) {
          // Remove the shift assignment (this will also remove hours via removeShift function)
          removeShift(personId, shiftCode, weekendKey);
          actionsPerformed.push('assignment');
        }
      }
      
      // Check if person refused this shift
      const refusalDetails = getShiftRefusalDetails(personId, shiftCode, weekendKey);
      if (refusalDetails && refusalDetails.refused) {
        const wasWorked = refusalDetails.worked;
        
        // If it was marked as worked, remove the hours first
        if (wasWorked) {
          const shift = SHIFT_DEFINITIONS[shiftCode];
          if (shift) {
            const shiftData = { shiftCode };
            removeHoursForShift(personId, shiftData, weekendKey);
          }
        }
        
        // Remove the refusal record
        unrefuseShift(personId, shiftCode, weekendKey);
        actionsPerformed.push(wasWorked ? 'worked refusal' : 'refusal');
      }
      
      // Return what was cleaned up for user feedback
      return {
        success: actionsPerformed.length > 0,
        actions: actionsPerformed
      };
    }
    
    // Mark a refused shift as worked (admin override)
    function markRefusedShiftAsWorked(personId, shiftCode, actualHours, weekendKey = getCurrentWeekendKey()){
      if (state.refusals[weekendKey] && 
          state.refusals[weekendKey][personId] && 
          state.refusals[weekendKey][personId][shiftCode]) {
        
        state.refusals[weekendKey][personId][shiftCode].worked = true;
        state.refusals[weekendKey][personId][shiftCode].actualHours = actualHours;
        saveRefusals();
      }
    }
    
    // Get refusal details for a shift
    function getShiftRefusalDetails(personId, shiftCode, weekendKey = getCurrentWeekendKey()){
      if (state.refusals[weekendKey] && 
          state.refusals[weekendKey][personId] && 
          state.refusals[weekendKey][personId][shiftCode]) {
        return state.refusals[weekendKey][personId][shiftCode];
      }
      return null;
    }
    
    // Legacy alias for getShiftRefusalDetails (for compatibility)
    function getShiftRefusal(personId, shiftCode, weekendKey = getCurrentWeekendKey()){
      return isShiftRefused(personId, shiftCode, weekendKey);
    }
    
    // Clear old refusal records (keep only current and future)
    function cleanupOldRefusals(){
      const currentKey = getCurrentWeekendKey();
      const currentDate = new Date(currentKey);
      const cutoffDate = new Date(currentDate);
      cutoffDate.setDate(cutoffDate.getDate() - 7); // Keep refusals for past week too
      
      let changed = false;
      Object.keys(state.refusals).forEach(weekendKey => {
        const weekendDate = new Date(weekendKey);
        if (weekendDate < cutoffDate) {
          delete state.refusals[weekendKey];
          changed = true;
        }
      });
      
      if (changed) {
        saveRefusals();
      }
    }
    
    // === Location Configuration System ===
    // Load location configuration
    function loadLocationConfig(){
      try { 
        const stored = localStorage.getItem(LOCATION_CONFIG_KEY);
        const config = stored ? JSON.parse(stored) : {};
        return config.locationCount || DEFAULT_LOCATION_COUNT;
      } catch(_) { return DEFAULT_LOCATION_COUNT; }
    }
    
    function saveLocationConfig(){
      try { 
        const config = {
          locationCount: state.locationCount,
          lastUpdated: new Date().toISOString()
        };
        localStorage.setItem(LOCATION_CONFIG_KEY, JSON.stringify(config)); 
      } catch(_) {}
    }
    
    // Calculate total shift capacity for a specific shift type
    function getShiftCapacity(shiftCode){
      return state.locationCount * PEOPLE_PER_SHIFT;
    }
    
    // Calculate total weekend capacity (all shifts combined)
    function getTotalWeekendCapacity(){
      return Object.keys(SHIFT_DEFINITIONS).length * state.locationCount * PEOPLE_PER_SHIFT;
    }
    
    // Get current number of people assigned to a specific shift
    function getShiftAssignedCount(shiftCode, weekendKey = getCurrentWeekendKey()){
      const assignments = state.shifts[weekendKey] || {};
      const count = Object.values(assignments)
        .filter(personData => personData.shifts && personData.shifts.some(s => s.shiftCode === shiftCode && s.worked === true))
        .length;
      // Debug: console.log(`⚡ getShiftAssignedCount(${shiftCode}): ${count} assignments (only worked shifts)`);
      return count;
    }
    
    // Get active shifts for the current weekend/location (for Who's Next shift buttons)
    function getActiveShiftsForWeekend(weekendKey = getCurrentWeekendKey()) {
      return Object.values(SHIFT_DEFINITIONS)
        .sort((a, b) => a.sequence - b.sequence)
        .map(shift => {
          const assigned = getShiftAssignedCount(shift.code, weekendKey);
          const capacity = getShiftCapacity(shift.code);
          const remaining = Math.max(0, capacity - assigned);
          const isFull = assigned >= capacity;
          
          return {
            code: shift.code,
            name: shift.name,
            shortDisplay: shift.shortDisplay,
            chargeableHours: shift.chargeableHours,
            sequence: shift.sequence,
            assigned,
            capacity,
            remaining,
            isFull
          };
        });
    }
    
    // Get remaining slots for a specific shift (for badge display)
    function getShiftRemainingSlots(shiftCode, weekendKey = getCurrentWeekendKey()) {
      const assigned = getShiftAssignedCount(shiftCode, weekendKey);
      const capacity = getShiftCapacity(shiftCode);
      return Math.max(0, capacity - assigned);
    }
    
    // Check if a shift is at full capacity
    function isShiftAtCapacity(shiftCode, weekendKey = getCurrentWeekendKey()){
      const assignedCount = getShiftAssignedCount(shiftCode, weekendKey);
      const capacity = getShiftCapacity(shiftCode);
      return assignedCount >= capacity;
    }
    
    // Get total number of people assigned across all shifts (only counts actually worked shifts)
    function getTotalAssignedPeople(weekendKey = getCurrentWeekendKey()){
      const assignments = state.shifts[weekendKey] || {};
      return Object.values(assignments)
        .filter(personData => personData.shifts && personData.shifts.some(s => s.worked === true))
        .length;
    }
    
    // Render weekend capacity summary
    function renderWeekendSummary(weekendKey = getCurrentWeekendKey()){
      console.log('🔄 renderWeekendSummary called with weekendKey:', weekendKey);
      
      if (!el.weekendSummary) {
        alert('Weekend Summary element not found!');
        return;
      }
      
      const totalAssigned = getTotalAssignedPeople(weekendKey);
      const totalCapacity = getTotalWeekendCapacity();
      const percentFilled = totalCapacity > 0 ? Math.round((totalAssigned / totalCapacity) * 100) : 0;
      
      console.log('📊 Weekend summary data:', {
        weekendKey,
        totalAssigned,
        totalCapacity,
        percentFilled,
        stateShifts: state.shifts[weekendKey] || {}
      });
      
      // Calculate weekend date range (Friday → Monday)
      const weekendDate = new Date(weekendKey);
      const monday = new Date(weekendDate);
      monday.setDate(monday.getDate() + 3); // Friday + 3 = Monday
      
      const dateFormat = { month: 'short', day: 'numeric' };
      const fridayStr = weekendDate.toLocaleDateString(undefined, dateFormat);
      const mondayStr = monday.toLocaleDateString(undefined, dateFormat);
      const dateRangeStr = `${fridayStr} → ${mondayStr}`;
      
      // Get previous weekend info for context
      const prevWeekend = getPreviousWeekend();
      const prevFridayStr = prevWeekend.friday.toLocaleDateString(undefined, dateFormat);
      const prevMondayStr = prevWeekend.monday.toLocaleDateString(undefined, dateFormat);
      const prevDateRangeStr = `${prevFridayStr} → ${prevMondayStr}`;
      
      // Determine status text based on current day
      const today = new Date();
      const dayOfWeek = today.getDay();
      let statusText = '';
      if (dayOfWeek >= 2 && dayOfWeek <= 4) { // Tue-Thu
        statusText = `Working for: ${dateRangeStr} • Last: ${prevDateRangeStr}`;
      } else {
        statusText = dateRangeStr;
      }
      
      // Get per-shift breakdown in proper order (sequence-based)
      const shiftBreakdown = Object.values(SHIFT_DEFINITIONS)
        .sort((a, b) => a.sequence - b.sequence)
        .map(shift => {
          const assigned = getShiftAssignedCount(shift.code, weekendKey);
          const capacity = getShiftCapacity(shift.code);
          const percentage = capacity > 0 ? Math.round((assigned / capacity) * 100) : 0;
          
          console.log(`🔍 Shift ${shift.code}:`, {
            assigned,
            capacity,
            percentage,
            locationCount: state.locationCount
          });
          
          let status = 'empty';
          if (assigned >= capacity) {
            status = 'full';
          } else if (assigned > 0) {
            status = 'partial';
          }
          
          return {
            name: shift.name, // Use full name for better display
            shortDisplay: shift.shortDisplay,
            assigned,
            capacity,
            percentage,
            status,
            isFull: assigned >= capacity
          };
        });
      
      const summaryHtml = `
        <div class="weekend-capacity-summary">
          <div class="weekend-header">
            <div class="weekend-title">
              <strong>Weekend Status</strong>
              <span class="weekend-dates">${statusText}</span>
            </div>
            <div class="overall-progress">
              <div class="status-header">
                ${totalAssigned}/${totalCapacity} positions filled (${percentFilled}%)
              </div>
              <div class="progress-bar-container">
                <div class="progress-bar">
                  <div class="progress-fill" style="width: ${percentFilled}%"></div>
                </div>
              </div>
            </div>
          </div>
          <div class="shift-breakdown">
            ${shiftBreakdown.map(shift => `
              <div class="shift-status ${shift.status}">
                <div class="shift-info">
                  <span class="shift-name">${shift.shortDisplay}</span>
                  ${shift.isFull ? '<span class="full-badge">FULL</span>' : ''}
                </div>
                <div class="shift-metrics">
                  <span class="shift-count">${shift.assigned}/${shift.capacity}</span>
                  <div class="mini-progress">
                    <div class="mini-fill" style="width: ${shift.percentage}%"></div>
                  </div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
      
      console.log('🎨 Setting weekend summary HTML:', summaryHtml);
      el.weekendSummary.innerHTML = summaryHtml;
      
      // Update mobile weekend status bar
      const mobileStatus = document.getElementById('mobileWeekendStatus');
      const mobileStatusChips = document.getElementById('mobileStatusChips');
      const mobileWeekendDates = document.getElementById('mobileWeekendDates');
      
      if (mobileStatus && mobileStatusChips && mobileWeekendDates) {
        // Update mobile dates
        mobileWeekendDates.textContent = statusText;
        
        // Create chips for each shift
        const chipsHtml = shiftBreakdown.map(shift => {
          const remaining = Math.max(0, shift.capacity - shift.assigned);
          let chipClass = 'status-chip ';
          
          if (shift.assigned >= shift.capacity) {
            chipClass += 'filled';
          } else if (shift.assigned > 0) {
            chipClass += 'partial';
          } else {
            chipClass += 'empty';
          }
          
          return `
            <div class="${chipClass}">
              <span>${shift.shortDisplay}</span>
              <span>${remaining} left</span>
            </div>
          `;
        }).join('');
        
        mobileStatusChips.innerHTML = chipsHtml;
        console.log('📱 Mobile weekend status updated');
      }
      
      console.log('✅ Weekend summary updated in DOM');
    }
    
    // Update location count and save configuration
    function updateLocationCount(newCount){
      const clampedCount = Math.max(1, Math.min(10, parseInt(newCount) || DEFAULT_LOCATION_COUNT));
      state.locationCount = clampedCount;
      saveLocationConfig();
      
      // Update UI displays if they exist
      const shiftCapacityEl = document.getElementById('shiftCapacity');
      const totalCapacityEl = document.getElementById('totalCapacity');
      
      if (shiftCapacityEl) {
        shiftCapacityEl.textContent = `${getShiftCapacity('any')} people`;
      }
      if (totalCapacityEl) {
        totalCapacityEl.textContent = `${getTotalWeekendCapacity()} people`;
      }
      
      // Re-render to update capacity indicators throughout the UI
      renderWhosNext();
    }
    
    // === Shift Storage System ===
    // Load shift assignments
    function loadShifts(){
      try {
        const stored = localStorage.getItem(SHIFTS_KEY);
        return stored ? JSON.parse(stored) : {};
      } catch(_) { return {}; }
    }
    
    function saveShifts(){
      try { localStorage.setItem(SHIFTS_KEY, JSON.stringify(state.shifts)); } catch(_) {}
    }

    // Get shifts for a specific person in a weekend
    function getPersonShifts(personId, weekendKey){
      return state.shifts[weekendKey]?.[personId] || null;
    }

    // Assign a shift to a person
    function assignShift(personId, shiftCode, weekendKey){
      console.log('🟢 ASSIGN SHIFT FUNCTION CALLED');
      console.log(`   Person: ${personId}, Shift: ${shiftCode}, Weekend: ${weekendKey}`);
      
      const shift = SHIFT_DEFINITIONS[shiftCode];
      if (!shift) {
        console.log('❌ Shift definition not found');
        return false;
      }
      
      console.log('   Shift Definition:', shift);
      
      // Check eligibility first
      const eligibility = canWorkShift(personId, shiftCode, weekendKey);
      if (!eligibility.eligible) {
        alert(eligibility.reason);
        return false;
      }
      
      // Check if person is already assigned to this shift (prevent double-assignment)
      const existingPersonShifts = state.shifts[weekendKey]?.[personId];
      if (existingPersonShifts && existingPersonShifts.shifts) {
        const alreadyAssigned = existingPersonShifts.shifts.some(s => s.shiftCode === shiftCode);
        if (alreadyAssigned) {
          const message = `Person is already assigned to ${shift.name}`;
          console.log('❌ Double-assignment prevented:', message);
          alert(message);
          return false;
        }
      }
      
      // Check capacity (defensive check to prevent over-assignment)
      const currentAssigned = getShiftAssignedCount(shiftCode, weekendKey);
      const capacity = getShiftCapacity(shiftCode);
      if (currentAssigned >= capacity) {
        const message = `Cannot assign shift: ${shift.name} is full (${currentAssigned}/${capacity})`;
        alert(message);
        return false;
      }
      
      // If this shift was previously refused, un-refuse it when assigning
      const wasRefused = isShiftRefused(personId, shiftCode, weekendKey);
      if (wasRefused) {
        unrefuseShift(personId, shiftCode, weekendKey);
        console.log(`Auto-un-refused shift ${shiftCode} for person ${personId} during assignment`);
      }
      
      // Initialize weekend if needed
      if (!state.shifts[weekendKey]) state.shifts[weekendKey] = {};
      if (!state.shifts[weekendKey][personId]) {
        state.shifts[weekendKey][personId] = { shifts: [], totalHours: 0, chargeableHours: 0 };
      }
      
      const personData = state.shifts[weekendKey][personId];
      
      // Calculate actual dates for this shift
      const weekend = getCurrentWeekend();
      console.log('   Current Weekend:', weekend);
      const shiftDates = calculateShiftDates(shift, weekend);
      console.log('   Calculated Shift Dates:', shiftDates);
      
      
      // Add shift (default to worked = true, can be changed if marked as refusal)
      personData.shifts.push({
        shiftCode,
        startTime: shiftDates.start,
        endTime: shiftDates.end,
        totalHours: shift.totalHours,
        regularHours: shift.regularHours,
        overtimeHours: shift.overtimeHours,
        chargeableHours: shift.chargeableHours,
        worked: true  // Default to worked, will be updated if marked as refusal
      });
      
      // Update totals
      personData.totalHours += shift.totalHours;
      personData.chargeableHours += shift.chargeableHours;
      personData.lastShiftEnd = shiftDates.end;
      
      // Add hours to the main hours tracking system for table display
      const newShiftData = personData.shifts[personData.shifts.length - 1];
      console.log('🟣 About to call addHoursForShift from assignShift');
      console.log('   New Shift Data:', newShiftData);
      addHoursForShift(personId, newShiftData, weekendKey);
      
      saveShifts();
      
      // Invalidate eligibility cache after assignment
      invalidateEligibilityCache();
      
      console.log('✅ ASSIGN SHIFT COMPLETED SUCCESSFULLY');
      return true;
    }

    // Remove a shift assignment
    function removeShift(personId, shiftCode, weekendKey){
      const personData = state.shifts[weekendKey]?.[personId];
      if (!personData) return false;
      
      const shiftIndex = personData.shifts.findIndex(s => s.shiftCode === shiftCode);
      if (shiftIndex === -1) return false;
      
      const shift = personData.shifts[shiftIndex];
      const shiftDef = SHIFT_DEFINITIONS[shift.shiftCode];
      
      // Remove hours from the main hours tracking system before removing shift
      removeHoursForShift(personId, shift, weekendKey);
      
      // Remove the shift
      personData.shifts.splice(shiftIndex, 1);
      
      // Update totals
      personData.totalHours -= shiftDef.totalHours;
      personData.chargeableHours -= shiftDef.chargeableHours;
      
      // Update lastShiftEnd if this was the last shift
      if (personData.shifts.length === 0) {
        personData.lastShiftEnd = null;
      } else {
        const lastShift = personData.shifts[personData.shifts.length - 1];
        const weekend = getCurrentWeekend();
        const lastShiftDef = SHIFT_DEFINITIONS[lastShift.shiftCode];
        const lastShiftDates = calculateShiftDates(lastShiftDef, weekend);
        personData.lastShiftEnd = lastShiftDates.end;
      }
      
      // Clean up empty person data
      if (personData.shifts.length === 0) {
        delete state.shifts[weekendKey][personId];
      }
      
      saveShifts();
      
      // Invalidate eligibility cache after removing shift
      invalidateEligibilityCache();
      
      return true;
    }

    // === Hours Integration Helper Functions ===
    
    // Add shift hours to the main hours tracking system
    function addHoursForShift(personId, shiftData, weekendKey){
      console.log('🔴 ADD HOURS FOR SHIFT CALLED');
      console.log(`   Person: ${personId}, Weekend: ${weekendKey}`);
      console.log(`   Shift Data:`, shiftData);
      
      const shift = SHIFT_DEFINITIONS[shiftData.shiftCode];
      if (!shift) {
        console.log('❌ Shift definition not found in addHoursForShift');
        return false;
      }
      
      console.log(`   Shift Definition:`, shift);
      
      // Calculate the dates this shift spans
      const weekend = getCurrentWeekend();
      console.log(`   Current Weekend for hours:`, weekend);
      const shiftDates = calculateShiftDates(shift, weekend);
      console.log(`   Shift Dates for hours:`, shiftDates);
      const startDate = new Date(shiftDates.start);
      const endDate = new Date(shiftDates.end);
      
      // Initialize person's hours if needed
      if (!state.hours[personId]) {
        state.hours[personId] = {};
      }
      
      // Determine which dates this shift covers
      const coveredDates = getDatesCoveredByShift(startDate, endDate, shift);
      console.log(`   Covered Dates:`, coveredDates);
      
      console.log(`   Before adding hours, state.hours[${personId}]:`, state.hours[personId]);
      
      // Add hours to each date this shift covers
      for (const dateInfo of coveredDates) {
        const dateKey = dateInfo.date; // YYYY-MM-DD format
        const hours = dateInfo.hours; // Hours for this specific date
        
        console.log(`   🎯 Adding ${hours} hours to date ${dateKey} for person ${personId}`);
        
        if (hours > 0) {
          const currentHours = parseFloat(state.hours[personId][dateKey] || 0);
          state.hours[personId][dateKey] = parseFloat((currentHours + hours).toFixed(2));
          console.log(`   ✅ Added! Total hours for ${dateKey} now: ${state.hours[personId][dateKey]}`);
        }
      }
      
      console.log(`   After adding hours, state.hours[${personId}]:`, state.hours[personId]);
      
      // CRITICAL: Also save hours to the shift-specific system that the main table reads from
      setShiftHours(personId, shiftData.shiftCode, weekendKey, shift.chargeableHours);
      console.log(`   ✅ Also saved ${shift.chargeableHours}h to shift system for ${shiftData.shiftCode}`);
      
      saveHours();
      return true;
    }
    
    // Remove shift hours from the main hours tracking system
    function removeHoursForShift(personId, shiftData, weekendKey){
      const shift = SHIFT_DEFINITIONS[shiftData.shiftCode];
      if (!state.hours[personId]) return false;
      
      // Calculate the dates this shift spans
      const weekend = getCurrentWeekend();
      const shiftDates = calculateShiftDates(shift, weekend);
      const startDate = new Date(shiftDates.start);
      const endDate = new Date(shiftDates.end);
      
      // Determine which dates this shift covers
      const coveredDates = getDatesCoveredByShift(startDate, endDate, shift);
      
      // Remove hours from each date this shift covers
      for (const dateInfo of coveredDates) {
        const dateKey = dateInfo.date; // YYYY-MM-DD format
        const hours = dateInfo.hours; // Hours for this specific date
        
        if (hours > 0 && state.hours[personId][dateKey]) {
          const currentHours = parseFloat(state.hours[personId][dateKey] || 0);
          const newHours = currentHours - hours;
          
          if (newHours <= 0) {
            delete state.hours[personId][dateKey];
          } else {
            state.hours[personId][dateKey] = parseFloat(newHours.toFixed(2));
          }
        }
      }
      
      // CRITICAL: Also remove hours from the shift-specific system that the main table reads from
      setShiftHours(personId, shiftData.shiftCode, weekendKey, 0);
      console.log(`   ✅ Also removed hours from shift system for ${shiftData.shiftCode}`);
      
      saveHours();
      return true;
    }
    
    // Get the dates and hours distribution for a shift
    function getDatesCoveredByShift(startDate, endDate, shift){
      const coveredDates = [];
      
      // For simplicity, we'll distribute hours based on the shift definition
      // Most shifts are within a single calendar date, but overnight shifts span two dates
      const startDateKey = startDate.toISOString().split('T')[0]; // YYYY-MM-DD
      const endDateKey = endDate.toISOString().split('T')[0]; // YYYY-MM-DD
      
      if (startDateKey === endDateKey) {
        // Single day shift - use chargeable hours for main table
        coveredDates.push({
          date: startDateKey,
          hours: shift.chargeableHours
        });
      } else {
        // Overnight shift - put chargeable hours on start date
        // (For "Fri 10p-Sat 2p", this puts 8 hours on Friday)
        coveredDates.push({
          date: startDateKey,
          hours: shift.chargeableHours
        });
      }
      
      return coveredDates;
    }
    
    // Central function to sync shift data with hours tracking
    function syncShiftHours(personId, shiftData, weekendKey, shouldAdd){
      if (shouldAdd) {
        return addHoursForShift(personId, shiftData, weekendKey);
      } else {
        return removeHoursForShift(personId, shiftData, weekendKey);
      }
    }

    // Calculate actual dates for a shift based on weekend
    function calculateShiftDates(shift, weekend){
      const friday = weekend.friday;
      const dayOffsets = { 'fri': 0, 'sat': 1, 'sun': 2, 'mon': 3 };
      
      const startDate = new Date(friday);
      startDate.setDate(startDate.getDate() + dayOffsets[shift.startDay]);
      const [startHour, startMin] = shift.startTime.split(':').map(Number);
      startDate.setHours(startHour, startMin, 0, 0);
      
      const endDate = new Date(friday);
      endDate.setDate(endDate.getDate() + dayOffsets[shift.endDay]);
      const [endHour, endMin] = shift.endTime.split(':').map(Number);
      endDate.setHours(endHour, endMin, 0, 0);
      
      return { start: startDate.toISOString(), end: endDate.toISOString() };
    }

    // Check if person can work a specific shift
    function canWorkShift(personId, shiftCode, weekendKey){
      const shift = SHIFT_DEFINITIONS[shiftCode];
      const personData = state.shifts[weekendKey]?.[personId];
      
      if (!personData || personData.shifts.length === 0) {
        return { eligible: true }; // No prior shifts, can work any shift
      }
      
      // Calculate the proposed shift start time
      const weekend = getCurrentWeekend();
      const proposedShiftDates = calculateShiftDates(shift, weekend);
      const proposedStartTime = proposedShiftDates.start;
      
      // Find the most recent worked tour that ends before the proposed shift start
      const lastWorkedTourEndTime = getLastWorkedTourEndTime(personId, proposedStartTime, weekendKey);
      
      console.log(`🔍 Overtime Eligibility Check for ${personId} -> ${shiftCode}`);
      console.log(`   Proposed shift start: ${proposedStartTime}`);
      console.log(`   Last worked tour end: ${lastWorkedTourEndTime || 'None'}`);
      console.log(`   Current person shifts:`, personData.shifts);
      
      // Debug: Show which shifts are actually worked vs refused
      const allShifts = personData.shifts.map(s => ({
        code: s.shiftCode,
        worked: s.worked,
        hours: s.totalHours
      }));
      console.log(`   Shift breakdown (worked only count for break rules):`, allShifts);
      
      if (lastWorkedTourEndTime) {
        // Calculate rest hours between the end of the last worked tour and the proposed shift start
        const lastTourEnd = new Date(lastWorkedTourEndTime);
        const proposedStart = new Date(proposedStartTime);
        const restHours = (proposedStart - lastTourEnd) / (1000 * 60 * 60);
        
        console.log(`   Rest hours available: ${restHours.toFixed(1)}h`);
        
        // Rule: Need 8-hour break after any worked tour that ended at/over 16 hours
        // Find the tour that ended at lastWorkedTourEndTime to check its total hours
        const workedShifts = personData.shifts.filter(shift => {
          const shiftEnd = new Date(shift.endTime);
          return shift.worked === true && shiftEnd <= new Date(proposedStartTime);
        });
        
        if (workedShifts.length > 0) {
          workedShifts.sort((a, b) => new Date(a.endTime) - new Date(b.endTime));
          const mostRecentShift = workedShifts[workedShifts.length - 1];
          const lastTour = findContinuousTourEndingWith(workedShifts, mostRecentShift);
          
          console.log(`   Last tour: ${lastTour.totalHours}h total (${lastTour.isLongTour ? '≥16h' : '<16h'})`);
          console.log(`   Last tour shifts: ${lastTour.shifts.map(s => SHIFT_DEFINITIONS[s.shiftCode].shortDisplay).join(' + ')}`);
          
          if (lastTour.isLongTour && restHours < 8) {
            console.log(`   ❌ BLOCKED: Insufficient rest after ${lastTour.totalHours}h tour`);
            console.log(`   ❌ SPECIFIC: Trying ${shiftCode} after working ${lastTour.shifts.map(s => s.shiftCode).join('+')} with ${restHours}h break`);
            return {
              eligible: false,
              reason: `Needs 8-hour break after working ${lastTour.totalHours}-hour tour (only ${restHours.toFixed(1)}h break)`
            };
          } else {
            console.log(`   ✅ REST OK: ${restHours >= 8 ? 'Adequate rest' : 'Tour <16h, no rest required'}`);
          }
        }
      } else {
        console.log(`   ✅ NO PRIOR TOURS: Eligible for any shift`);
      }
      
      // Rule: Can't exceed 16 consecutive hours
      if (wouldExceedConsecutiveLimit(personData, shift)) {
        return {
          eligible: false,
          reason: 'Would exceed 16-hour consecutive work limit'
        };
      }
      
      // Check for shift conflicts
      if (hasShiftConflict(personData, shift, weekendKey)) {
        return {
          eligible: false,
          reason: 'Conflicts with existing shift assignment'
        };
      }
      
      return { eligible: true };
    }

    // Get the end time of the most recent worked tour that ends on or before the given time
    function getLastWorkedTourEndTime(personId, beforeTime, weekendKey){
      const personData = state.shifts[weekendKey]?.[personId];
      if (!personData || !personData.shifts || personData.shifts.length === 0) {
        return null; // No shifts worked
      }
      
      const beforeTimestamp = new Date(beforeTime);
      let lastWorkedTourEnd = null;
      
      // Find all worked shifts that end before the given time
      const workedShifts = personData.shifts.filter(shift => {
        const shiftEnd = new Date(shift.endTime);
        return shift.worked === true && shiftEnd <= beforeTimestamp;
      });
      
      if (workedShifts.length === 0) {
        return null; // No worked shifts before the given time
      }
      
      // Sort by end time to find continuous tours
      workedShifts.sort((a, b) => new Date(a.endTime) - new Date(b.endTime));
      
      // Find the actual end of the most recent continuous tour
      const mostRecentShift = workedShifts[workedShifts.length - 1];
      const continuousTour = findContinuousTourEndingWith(workedShifts, mostRecentShift);
      
      return continuousTour.actualEndTime;
    }
    
    // Check if shifts form a continuous tour (back-to-back with <1 hour gaps)
    function isContinuousTour(shifts){
      if (shifts.length <= 1) return true;
      
      // Sort shifts by start time
      const sortedShifts = shifts.slice().sort((a, b) => new Date(a.startTime) - new Date(b.startTime));
      
      for (let i = 1; i < sortedShifts.length; i++) {
        const prevEnd = new Date(sortedShifts[i-1].endTime);
        const currStart = new Date(sortedShifts[i].startTime);
        const gapHours = (currStart - prevEnd) / (1000 * 60 * 60);
        
        if (gapHours >= 1) {
          return false; // Gap of 1 hour or more breaks continuity
        }
      }
      
      return true;
    }
    
    // Find the continuous tour that ends with a specific shift
    function findContinuousTourEndingWith(allShifts, targetShift){
      const targetEndTime = new Date(targetShift.endTime);
      
      // Start with the target shift and work backwards to find the continuous tour
      let tourShifts = [targetShift];
      let tourStart = new Date(targetShift.startTime);
      let tourEnd = targetEndTime;
      let totalHours = targetShift.totalHours;
      
      // Work backwards to find connected shifts
      for (let i = allShifts.length - 2; i >= 0; i--) {
        const candidateShift = allShifts[i];
        const candidateEnd = new Date(candidateShift.endTime);
        const gapHours = (tourStart - candidateEnd) / (1000 * 60 * 60);
        
        if (gapHours < 1 && gapHours >= 0) {
          // This shift connects to our tour (ends within 1 hour of tour start)
          tourShifts.unshift(candidateShift);
          tourStart = new Date(candidateShift.startTime);
          totalHours += candidateShift.totalHours;
        } else {
          break; // Gap is too large, tour starts here
        }
      }
      
      return {
        shifts: tourShifts,
        actualStartTime: tourStart.toISOString(),
        actualEndTime: tourEnd.toISOString(),
        totalHours: totalHours,
        isLongTour: totalHours >= 16
      };
    }
    
    // Calculate break hours between shifts
    function calculateBreakHours(lastEndTime, nextShift){
      const lastEnd = new Date(lastEndTime);
      const weekend = getCurrentWeekend();
      const nextDates = calculateShiftDates(nextShift, weekend);
      const nextStart = new Date(nextDates.start);
      
      const breakMs = nextStart - lastEnd;
      return breakMs / (1000 * 60 * 60); // Convert to hours
    }

    // Check if adding shift would exceed consecutive hour limit
    function wouldExceedConsecutiveLimit(personData, nextShift){
      if (!personData.lastShiftEnd) return false;
      
      const lastEnd = new Date(personData.lastShiftEnd);
      const weekend = getCurrentWeekend();
      const nextDates = calculateShiftDates(nextShift, weekend);
      const nextStart = new Date(nextDates.start);
      
      // If shifts are back-to-back (less than 1 hour gap)
      const gapHours = (nextStart - lastEnd) / (1000 * 60 * 60);
      if (gapHours < 1) {
        // Check total consecutive hours
        const lastShift = personData.shifts[personData.shifts.length - 1];
        const consecutiveHours = lastShift.totalHours + nextShift.totalHours;
        return consecutiveHours > 16;
      }
      
      return false;
    }

    // Check for shift conflicts
    function hasShiftConflict(personData, nextShift, weekendKey){
      // Check if person already has a shift that overlaps
      for (const existing of personData.shifts) {
        const existingDef = SHIFT_DEFINITIONS[existing.shiftCode];
        // Simple check: same shift sequence number means conflict
        if (existingDef.sequence === nextShift.sequence) {
          return true;
        }
      }
      return false;
    }

    // Get next available shift for the weekend (capacity-based)
    function getNextAvailableShift(weekendKey){
      const allShifts = Object.values(SHIFT_DEFINITIONS).sort((a, b) => a.sequence - b.sequence);
      
      for (const shift of allShifts) {
        // Check if shift is at capacity instead of just assigned
        if (!isShiftAtCapacity(shift.code, weekendKey)) {
          return shift;
        }
      }
      
      return null; // All shifts at capacity
    }
    
    // === ACCEPT OT ELIGIBILITY POOL LOGIC ===
    
    // Get the eligibility pool for a specific shift (people who should see Accept OT button)
    function getEligibilityPoolForShift(shiftCode, weekendKey = getCurrentWeekendKey()) {
      const capacity = getShiftCapacity(shiftCode);
      const assigned = getShiftAssignedCount(shiftCode, weekendKey);
      const remaining = capacity - assigned;
      
      if (remaining <= 0) {
        return []; // No capacity, no one is eligible
      }
      
      // Get all non-excluded people with their current totals
      const allPeople = state.items
        .filter(person => !isPersonExcluded(person.id, weekendKey))
        .map(person => {
          const listInfo = parseListNumber(person.lisNumber);
          return {
            id: person.id,
            name: person.name,
            total: effectiveTotal(person.id),
            listNumber: listInfo.number,
            isProvisional: listInfo.isProvisional,
            lastChange: getLastChange(person.id)
          };
        })
        .sort((a, b) => {
          // Primary sort: by hours (lowest first)
          if (a.total !== b.total) return a.total - b.total;
          
          // Secondary sort: by last change time
          if (a.lastChange !== b.lastChange) return a.lastChange - b.lastChange;
          
          // Tertiary sort: by seniority - provisional workers have lowest seniority
          if (a.isProvisional && !b.isProvisional) return 1;
          if (!a.isProvisional && b.isProvisional) return -1;
          
          // If both have same provisional status, compare by list numbers
          if (a.listNumber !== b.listNumber) return a.listNumber - b.listNumber;
          return 0;
        });
      
      // Filter for people who can actually work this shift
      const eligiblePeople = allPeople.filter(person => {
        const eligibility = canWorkShift(person.id, shiftCode, weekendKey);
        const alreadyAssigned = isPersonAssignedToShift(person.id, shiftCode, weekendKey);
        const hasRefused = isShiftRefused(person.id, shiftCode, weekendKey);
        
        return eligibility.eligible && !alreadyAssigned && !hasRefused;
      });
      
      // Return only the lowest-hours pool, limited to available slots
      // This implements the fairness requirement
      const fairnessPool = eligiblePeople.slice(0, remaining);
      console.log(`🎯 Fairness Pool for ${shiftCode}: ${fairnessPool.map(p => `${p.name}(${p.total}h, #${p.listNumber})`).join(', ')}`);
      return fairnessPool;
    }
    
    // Check if a specific person is in the fairness pool for a shift (without pre-filtering)
    function checkPersonInFairnessPool(personId, shiftCode, weekendKey = getCurrentWeekendKey()) {
      const capacity = getShiftCapacity(shiftCode);
      const assigned = getShiftAssignedCount(shiftCode, weekendKey);
      const remaining = capacity - assigned;
      
      if (remaining <= 0) {
        return { eligible: false, reason: `Shift is full (${assigned}/${capacity})` };
      }
      
      // Get ALL non-excluded people with their current totals  
      const allPeople = state.items
        .filter(person => !isPersonExcluded(person.id, weekendKey))
        .map(person => {
          const listInfo = parseListNumber(person.lisNumber);
          return {
            id: person.id,
            name: person.name,
            total: effectiveTotal(person.id),
            listNumber: listInfo.number,
            isProvisional: listInfo.isProvisional,
            lastChange: getLastChange(person.id)
          };
        })
        .sort((a, b) => {
          // Primary sort: by hours (lowest first)
          if (a.total !== b.total) return a.total - b.total;
          
          // Secondary sort: by last change time
          if (a.lastChange !== b.lastChange) return a.lastChange - b.lastChange;
          
          // Tertiary sort: by seniority - provisional workers have lowest seniority
          if (a.isProvisional && !b.isProvisional) return 1;
          if (!a.isProvisional && b.isProvisional) return -1;
          
          // If both have same provisional status, compare by list numbers
          if (a.listNumber !== b.listNumber) return a.listNumber - b.listNumber;
          return 0;
        });
      
      // Filter for people who can actually work this shift (eligibility rules)
      const eligiblePeople = allPeople.filter(person => {
        const eligibility = canWorkShift(person.id, shiftCode, weekendKey);
        const alreadyAssigned = isPersonAssignedToShift(person.id, shiftCode, weekendKey);
        const hasRefused = isShiftRefused(person.id, shiftCode, weekendKey);
        
        return eligibility.eligible && !alreadyAssigned && !hasRefused;
      });
      
      // Find this person's position in the eligible list
      const personIndex = eligiblePeople.findIndex(p => p.id === personId);
      if (personIndex === -1) {
        return { eligible: false, reason: 'Not eligible due to break/rest rules or already assigned/refused' };
      }
      
      // Check if they're in the fairness pool (top N people where N = remaining slots)
      if (personIndex < remaining) {
        return { eligible: true };
      } else {
        // They're eligible but not in the fairness pool
        const personTotal = eligiblePeople[personIndex].total;
        const personListNum = eligiblePeople[personIndex].listNumber;
        const cutoffPerson = eligiblePeople[remaining - 1];
        
        if (personTotal === cutoffPerson.total) {
          // Same hours, but higher list number
          return { 
            eligible: false, 
            reason: `Tied at ${personTotal}h but offered to lower list numbers (need list #≤${cutoffPerson.listNumber}, you're #${personListNum})`
          };
        } else {
          // Higher hours
          return { 
            eligible: false, 
            reason: `Offered to people with fewer hours (need ≤${cutoffPerson.total}h, you have ${personTotal}h)`
          };
        }
      }
    }
    
    // Check if person is already assigned to a specific shift
    function isPersonAssignedToShift(personId, shiftCode, weekendKey) {
      const personShifts = getPersonShifts(personId, weekendKey);
      return personShifts?.shifts?.some(s => s.shiftCode === shiftCode) || false;
    }
    
    // Get Accept OT button state for a person and shift
    function getAcceptOTButtonState(personId, shiftCode, weekendKey = getCurrentWeekendKey()) {
      // Check if already assigned
      if (isPersonAssignedToShift(personId, shiftCode, weekendKey)) {
        return {
          state: 'assigned',
          label: 'Assigned',
          disabled: true,
          cssClass: 'accept-ot-assigned',
          title: 'Already assigned to this shift'
        };
      }
      
      // Check capacity
      const capacity = getShiftCapacity(shiftCode);
      const assigned = getShiftAssignedCount(shiftCode, weekendKey);
      if (assigned >= capacity) {
        return {
          state: 'full',
          label: 'Full',
          disabled: true,
          cssClass: 'accept-ot-full',
          title: `Shift is full (${assigned}/${capacity})`
        };
      }
      
      // Check eligibility (rest rules, etc.)
      const eligibility = canWorkShift(personId, shiftCode, weekendKey);
      if (!eligibility.eligible) {
        return {
          state: 'rest-blocked',
          label: 'Blocked',
          disabled: true,
          cssClass: 'accept-ot-blocked',
          title: eligibility.reason
        };
      }
      
      // Check if person refused this shift
      if (isShiftRefused(personId, shiftCode, weekendKey)) {
        return {
          state: 'refused',
          label: 'Refused',
          disabled: true,
          cssClass: 'accept-ot-refused',
          title: 'You have refused this shift'
        };
      }
      
      // Check if person is in fairness pool (instead of using pre-filtered pool)
      const isInFairnessPool = checkPersonInFairnessPool(personId, shiftCode, weekendKey);
      
      if (!isInFairnessPool.eligible) {
        return {
          state: 'locked',
          label: 'Locked',
          disabled: true,
          cssClass: 'accept-ot-locked',
          title: isInFairnessPool.reason
        };
      }
      
      // Available for acceptance
      return {
        state: 'available',
        label: 'Accept OT',
        disabled: false,
        cssClass: 'accept-ot-available',
        title: `Accept ${SHIFT_DEFINITIONS[shiftCode]?.shortDisplay} shift`
      };
    }
    
    // === REFUSAL BUTTON LOGIC ===
    
    // Get Refusal button state for a person and shift
    function getRefusalButtonState(personId, shiftCode, weekendKey = getCurrentWeekendKey()) {
      // Check if person already refused this shift
      if (isShiftRefused(personId, shiftCode, weekendKey)) {
        return {
          state: 'refused',
          label: 'Refused',
          disabled: true,
          cssClass: 'refuse-btn refused',
          title: 'You have refused this shift'
        };
      }
      
      // Check if person is already assigned to this shift
      if (isPersonAssignedToShift(personId, shiftCode, weekendKey)) {
        return {
          state: 'assigned',
          label: 'R',
          disabled: true,
          cssClass: 'refuse-btn disabled',
          title: 'Already assigned'
        };
      }
      
      // Check if shift is archived/canceled (capacity = 0 would indicate this)
      const capacity = getShiftCapacity(shiftCode);
      if (capacity <= 0) {
        return {
          state: 'closed',
          label: 'R',
          disabled: true,
          cssClass: 'refuse-btn disabled',
          title: 'Shift closed/canceled'
        };
      }
      
      // Check if shift is full (no longer being offered)
      const assigned = getShiftAssignedCount(shiftCode, weekendKey);
      if (assigned >= capacity) {
        return {
          state: 'full',
          label: 'R',
          disabled: true,
          cssClass: 'refuse-btn disabled',
          title: 'Shift is full'
        };
      }
      
      // Check if person is in fairness pool (same logic as Accept OT)
      const isInFairnessPool = checkPersonInFairnessPool(personId, shiftCode, weekendKey);
      
      if (!isInFairnessPool.eligible) {
        return {
          state: 'not-offered',
          label: 'R',
          disabled: true,
          cssClass: 'refuse-btn disabled',
          title: isInFairnessPool.reason
        };
      }
      
      // Available for refusal
      return {
        state: 'actionable',
        label: 'R',
        disabled: false,
        cssClass: 'refuse-btn',
        title: `Refuse ${SHIFT_DEFINITIONS[shiftCode]?.shortDisplay} shift`
      };
    }
    
    // === REFUSAL ATOMIC OPERATIONS ===
    
    // Handle Refusal button click with atomic validation and concurrency protection
    async function handleRefusal(personId, shiftCode, weekendKey, buttonElement) {
      console.log('🔴 REFUSAL OPERATION STARTED');
      console.log(`   Person: ${personId}, Shift: ${shiftCode}, Weekend: ${weekendKey}`);
      
      // Step 1: Soft-reserve during processing (prevent races)
      const originalButton = buttonElement.cloneNode(true);
      buttonElement.textContent = 'Pending...';
      buttonElement.className = 'refuse-btn pending';
      buttonElement.disabled = true;
      
      try {
        // Step 2: Re-validate conditions at moment of refusal
        const validation = validateRefusalConditions(personId, shiftCode, weekendKey);
        if (!validation.valid) {
          throw new Error(validation.reason);
        }
        
        // Step 3: Calculate chargeable hours (from OT window, not total shift)
        const shift = SHIFT_DEFINITIONS[shiftCode];
        const chargeableHours = shift.chargeableHours;
        
        console.log(`   Chargeable hours penalty: ${chargeableHours}h (from ${shift.totalHours}h total shift)`);
        
        // Step 4: Execute refusal atomically
        const success = executeRefusal(personId, shiftCode, weekendKey, chargeableHours);
        if (!success) {
          throw new Error('Refusal operation failed');
        }
        
        // Step 5: Create audit entry
        createAuditEntry('shift_refused', {
          personId,
          shiftCode,
          weekendKey,
          chargeableHours,
          totalShiftHours: shift.totalHours,
          timestamp: new Date().toISOString(),
          actor: 'user'
        });
        
        // Step 6: Live UI updates without page reload
        updateRefusalSuccess(personId, shiftCode, weekendKey, chargeableHours);
        
        console.log('✅ REFUSAL OPERATION COMPLETED SUCCESSFULLY');
        
      } catch (error) {
        console.error('❌ REFUSAL OPERATION FAILED:', error.message);
        
        // Restore original button state
        buttonElement.textContent = originalButton.textContent;
        buttonElement.className = originalButton.className;
        buttonElement.disabled = originalButton.disabled;
        
        // Show user-friendly error message
        showRefusalError(error.message);
      }
    }
    
    // Validate all refusal conditions atomically
    function validateRefusalConditions(personId, shiftCode, weekendKey) {
      // Check if person already refused this shift (idempotency)
      if (isShiftRefused(personId, shiftCode, weekendKey)) {
        return { valid: false, reason: 'You have already refused this shift.' };
      }
      
      // Check if person is already assigned to this shift
      if (isPersonAssignedToShift(personId, shiftCode, weekendKey)) {
        return { valid: false, reason: 'You are already assigned to this shift.' };
      }
      
      // Check if shift is full (offer expired)
      const capacity = getShiftCapacity(shiftCode);
      const assigned = getShiftAssignedCount(shiftCode, weekendKey);
      if (assigned >= capacity) {
        return { valid: false, reason: 'Offer expired - shift is now full.' };
      }
      
      // Check if person is still in fairness pool
      const isInFairnessPool = checkPersonInFairnessPool(personId, shiftCode, weekendKey);
      if (!isInFairnessPool.eligible) {
        return { valid: false, reason: isInFairnessPool.reason };
      }
      
      return { valid: true };
    }
    
    // Execute the refusal operation (adds hours but doesn't consume capacity)
    function executeRefusal(personId, shiftCode, weekendKey, chargeableHours) {
      try {
        console.log('🔄 Executing refusal...');
        
        // Add chargeable hours to person's adjustment total (fairness penalty)
        if (!state.adj[personId]) state.adj[personId] = 0;
        state.adj[personId] += chargeableHours;
        saveAdj();
        
        // Record the refusal (prevents re-offering)
        if (!state.refusals[weekendKey]) state.refusals[weekendKey] = {};
        if (!state.refusals[weekendKey][personId]) state.refusals[weekendKey][personId] = {};
        
        state.refusals[weekendKey][personId][shiftCode] = {
          refused: true,
          worked: false, // Key difference: person didn't work
          timestamp: new Date().toISOString(),
          chargeableHours: chargeableHours // Track what was charged
        };
        
        saveRefusals();
        
        // CRITICAL: Also add penalty hours to shift-specific system so they appear in main table shift cells
        // Use special refusal function that doesn't mark as "worked"
        setRefusalPenaltyHours(personId, shiftCode, weekendKey, chargeableHours);
        console.log(`   ✅ Also added ${chargeableHours}h penalty to shift cell for ${shiftCode} (not marked as worked)`);
        
        // IMPORTANT: Also record the refused shift in the shifts system with worked: false
        // This ensures the eligibility system knows about refusals and doesn't apply break rules to them
        const shift = SHIFT_DEFINITIONS[shiftCode];
        if (shift) {
          const weekend = getCurrentWeekend();
          const shiftDates = calculateShiftDates(shift, weekend);
          
          // Initialize shifts data if needed
          if (!state.shifts[weekendKey]) state.shifts[weekendKey] = {};
          if (!state.shifts[weekendKey][personId]) {
            state.shifts[weekendKey][personId] = { shifts: [], totalHours: 0, chargeableHours: 0 };
          }
          
          // Add refused shift with worked: false
          state.shifts[weekendKey][personId].shifts.push({
            shiftCode,
            startTime: shiftDates.start,
            endTime: shiftDates.end,
            totalHours: shift.totalHours,
            chargeableHours: shift.chargeableHours,
            worked: false  // Key difference: this was refused, not worked
          });
          
          saveShifts();
          console.log(`   ✅ Also recorded refused shift in shifts system with worked: false`);
        }
        
        // Update last change timestamp for ranking tie-breaker
        bumpLastChange(personId);
        
        // Invalidate eligibility cache
        invalidateEligibilityCache();
        
        console.log(`✅ Refusal executed: +${chargeableHours}h penalty, capacity unchanged`);
        return true;
        
      } catch (error) {
        console.error('❌ Refusal execution failed:', error);
        return false;
      }
    }
    
    // Update UI after successful refusal operation
    function updateRefusalSuccess(personId, shiftCode, weekendKey, chargeableHours) {
      // Invalidate eligibility cache
      invalidateEligibilityCache();
      
      // Update person totals instantly
      updatePersonTotalsInstantly(personId);
      
      // Re-render main table to show updated totals immediately
      render();
      
      // Show success feedback
      const person = state.items.find(p => p.id === personId);
      const shift = SHIFT_DEFINITIONS[shiftCode];
      const assignedCount = getShiftAssignedCount(shiftCode, weekendKey);
      const capacity = getShiftCapacity(shiftCode);
      
      console.log(`🔴 ${person?.name || 'Person'} refused ${shift?.name || shiftCode} (${assignedCount}/${capacity} filled, +${chargeableHours}h penalty)`);
    }
    
    // Show refusal error message
    function showRefusalError(message) {
      alert(message);
    }
    
    // === ACCEPT OT ATOMIC OPERATIONS ===
    
    // Handle Accept OT button click with atomic validation and concurrency protection
    async function handleAcceptOT(personId, shiftCode, weekendKey, buttonElement) {
      console.log('🟢 ACCEPT OT OPERATION STARTED');
      console.log(`   Person: ${personId}, Shift: ${shiftCode}, Weekend: ${weekendKey}`);
      console.log(`   Current Weekend Key: ${getCurrentWeekendKey()}`);
      console.log(`   Weekend Match: ${weekendKey === getCurrentWeekendKey()}`);
      
      // Step 1: Soft-reserve the slot (prevent races)
      const originalButton = buttonElement.cloneNode(true);
      buttonElement.textContent = 'Pending...';
      buttonElement.className = 'accept-ot-btn pending';
      buttonElement.disabled = true;
      
      try {
        // Step 2: Re-validate all conditions at moment of acceptance
        const validation = validateAcceptOTConditions(personId, shiftCode, weekendKey);
        if (!validation.valid) {
          throw new Error(validation.reason);
        }
        
        // Step 3: Calculate chargeable hours (using chargeable OT window)
        const shift = SHIFT_DEFINITIONS[shiftCode];
        const chargeableHours = shift.chargeableHours;
        
        console.log(`   Chargeable hours: ${chargeableHours}h (from ${shift.totalHours}h total shift)`);
        
        // Step 4: Write the assignment atomically
        const success = assignShift(personId, shiftCode, weekendKey);
        if (!success) {
          throw new Error('Shift assignment failed');
        }
        
        // Step 5: Create audit entry
        createAuditEntry('shift_accepted', {
          personId,
          shiftCode,
          weekendKey,
          chargeableHours,
          totalShiftHours: shift.totalHours,
          timestamp: new Date().toISOString(),
          actor: 'user'
        });
        
        // Step 6: Live UI updates without page reload
        updateAcceptOTSuccess(personId, shiftCode, weekendKey, chargeableHours);
        
        console.log('✅ ACCEPT OT OPERATION COMPLETED SUCCESSFULLY');
        
      } catch (error) {
        console.error('❌ ACCEPT OT OPERATION FAILED:', error.message);
        
        // Restore original button state
        buttonElement.textContent = originalButton.textContent;
        buttonElement.className = originalButton.className;
        buttonElement.disabled = originalButton.disabled;
        
        // Show user-friendly error message
        showAcceptOTError(error.message);
      }
    }
    
    // Validate all Accept OT conditions atomically
    function validateAcceptOTConditions(personId, shiftCode, weekendKey) {
      // Check if already assigned
      if (isPersonAssignedToShift(personId, shiftCode, weekendKey)) {
        return { valid: false, reason: 'You are already assigned to this shift.' };
      }
      
      // Check capacity
      const capacity = getShiftCapacity(shiftCode);
      const assigned = getShiftAssignedCount(shiftCode, weekendKey);
      if (assigned >= capacity) {
        return { valid: false, reason: 'That shift just filled—try another.' };
      }
      
      // Check eligibility (rest rules)
      const eligibility = canWorkShift(personId, shiftCode, weekendKey);
      if (!eligibility.eligible) {
        return { valid: false, reason: eligibility.reason };
      }
      
      // Check if person refused this shift
      if (isShiftRefused(personId, shiftCode, weekendKey)) {
        return { valid: false, reason: 'You have refused this shift.' };
      }
      
      // Check fairness pool
      const isInFairnessPool = checkPersonInFairnessPool(personId, shiftCode, weekendKey);
      if (!isInFairnessPool.eligible) {
        return { valid: false, reason: isInFairnessPool.reason };
      }
      
      return { valid: true };
    }
    
    // Update UI after successful Accept OT operation
    function updateAcceptOTSuccess(personId, shiftCode, weekendKey, chargeableHours) {
      // Invalidate eligibility cache
      invalidateEligibilityCache();
      
      // Update person totals instantly
      updatePersonTotalsInstantly(personId);
      
      // Re-render main table to show hours immediately
      render();
      
      // Show success feedback
      const person = state.items.find(p => p.id === personId);
      const shift = SHIFT_DEFINITIONS[shiftCode];
      const assignedCount = getShiftAssignedCount(shiftCode, weekendKey);
      const capacity = getShiftCapacity(shiftCode);
      
      console.log(`✅ ${person?.name || 'Person'} assigned to ${shift?.name || shiftCode} (${assignedCount}/${capacity} filled, +${chargeableHours}h)`);
    }
    
    // Show Accept OT error message
    function showAcceptOTError(message) {
      // For now, use alert - could be enhanced with a toast notification
      alert(message);
    }
    
    // Create audit entry for tracking
    function createAuditEntry(eventType, data) {
      try {
        const auditKey = 'accept_ot_audit_v1';
        const existingAudit = JSON.parse(localStorage.getItem(auditKey) || '[]');
        
        const entry = {
          id: `${eventType}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          eventType,
          timestamp: new Date().toISOString(),
          ...data
        };
        
        existingAudit.push(entry);
        
        // Keep only last 1000 entries to prevent storage bloat
        if (existingAudit.length > 1000) {
          existingAudit.splice(0, existingAudit.length - 1000);
        }
        
        localStorage.setItem(auditKey, JSON.stringify(existingAudit));
        console.log('📝 Audit entry created:', entry);
      } catch (error) {
        console.warn('Failed to create audit entry:', error);
      }
    }
    
    // Get all available shifts for a specific person (considering their eligibility and refusals)
    function getAvailableShiftsForPerson(personId, weekendKey = getCurrentWeekendKey()){
      const allShifts = Object.values(SHIFT_DEFINITIONS).sort((a, b) => a.sequence - b.sequence);
      const availableShifts = [];
      
      for (const shift of allShifts) {
        // Check if shift is at capacity instead of just assigned
        if (!isShiftAtCapacity(shift.code, weekendKey)) {
          // Check if person can work this shift (eligibility rules)
          const eligibility = canWorkShift(personId, shift.code, weekendKey);
          
          // Check if person refused this shift
          const isRefused = isShiftRefused(personId, shift.code, weekendKey);
          
          // Get capacity info for display
          const assignedCount = getShiftAssignedCount(shift.code, weekendKey);
          const capacity = getShiftCapacity(shift.code);
          
          availableShifts.push({
            ...shift,
            eligible: eligibility.eligible,
            ineligibleReason: eligibility.reason,
            refused: isRefused,
            canAssign: eligibility.eligible && !isRefused,
            canRefuse: eligibility.eligible && !isRefused,
            assignedCount: assignedCount,
            capacity: capacity,
            spotsRemaining: capacity - assignedCount
          });
        }
      }
      
      return availableShifts;
    }
    
    // Get refused shifts for a person that could potentially be un-refused
    function getRefusedShiftsForPerson(personId, weekendKey = getCurrentWeekendKey()){
      const refusedShifts = [];
      const refusalData = state.refusals[weekendKey]?.[personId] || {};
      
      Object.keys(refusalData).forEach(shiftCode => {
        const refusal = refusalData[shiftCode];
        if (refusal.refused) {
          const shiftDef = SHIFT_DEFINITIONS[shiftCode];
          if (shiftDef) {
            // Check if this shift still has capacity available
            if (!isShiftAtCapacity(shiftCode, weekendKey)) {
              const assignedCount = getShiftAssignedCount(shiftCode, weekendKey);
              const capacity = getShiftCapacity(shiftCode);
              
              refusedShifts.push({
                ...shiftDef,
                refusalDetails: refusal,
                assignedCount: assignedCount,
                capacity: capacity,
                spotsRemaining: capacity - assignedCount
              });
            }
          }
        }
      });
      
      return refusedShifts;
    }

    function setEditing(id){
      state.editingId = id;
      if (id){
        const item = state.items.find(x => x.id === id);
        if (!item) return clearForm();
        el.name.value = item.name;
        el.lisNumber.value = item.lisNumber || '';
        el.initialHours.value = effectiveTotal(item.id) || '';
        el.saveBtn.textContent = 'Save';
        el.cancelEditBtn.style.display = '';
        el.name.focus();
      } else {
        clearForm();
      }
    }

    function clearForm(){
      state.editingId = null;
      el.form.reset();
      el.saveBtn.textContent = 'Add';
      el.cancelEditBtn.style.display = 'none';
    }

    function normalize(str){ 
      const result = (str || '').toString().trim();
      // Remove any stray HTML or weird characters that could cause rendering issues
      return result.replace(/<[^>]*>/g, '').replace(/[\r\n\t]/g, ' ').replace(/\s+/g, ' ').trim();
    }

    function upsertItem(name, lisNumber, initialHours){
      name = normalize(name);
      lisNumber = normalize(lisNumber);
      initialHours = parseFloat(initialHours) || 0;
      
      // Validate required fields
      if (!name){
        alert('Please enter a name.');
        return;
      }
      
      // Validate hours if provided
      if (initialHours < 0) {
        alert('Hours cannot be negative.');
        return;
      }
      
      // Prevent numbers-only names
      if (/^\d+$/.test(name)) {
        alert('Name cannot be just numbers. Please enter a proper name.');
        return;
      }
      
      // Prevent date fragments in name
      const nameLower = name.toLowerCase();
      if (nameLower.includes('fri') || nameLower.includes('sat') || 
          nameLower.includes('sun') || nameLower.includes('mon') ||
          /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/.test(nameLower)) {
        alert('Name contains invalid date text. Please enter a proper name.');
        return;
      }
      
      // Prevent date fragments in list number
      if (lisNumber) {
        const lisLower = lisNumber.toLowerCase();
        if (lisLower.includes('fri') || lisLower.includes('sat') || 
            lisLower.includes('sun') || lisLower.includes('mon') ||
            /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/.test(lisLower)) {
          alert('List # contains invalid date text. Please enter only numbers.');
          return;
        }
      }

      // Optional: warn on duplicate LIS number if provided
      if (lisNumber){
        const dupLis = state.items.find(x => (x.lisNumber || '').toLowerCase() === lisNumber.toLowerCase() && x.id !== state.editingId);
        if (dupLis){
          const cont2 = confirm(`List # "${lisNumber}" already exists for "${dupLis.name}". Add anyway?`);
          if (!cont2) return;
        }
      }

      const now = new Date().toISOString();
      if (state.editingId){
        // Editing existing item
        const idx = state.items.findIndex(x => x.id === state.editingId);
        if (idx !== -1){
          state.items[idx] = { ...state.items[idx], name, lisNumber, updatedAt: now };
          
          // Update hours if provided during edit
          if (initialHours > 0) {
            const personId = state.editingId;
            const currentTotal = effectiveTotal(personId);
            const adjustment = initialHours - currentTotal;
            
            if (adjustment !== 0) {
              if (!state.adj[personId]) state.adj[personId] = 0;
              state.adj[personId] += adjustment;
              saveAdj();
            }
          }
        }
      } else {
        // Creating new item
        const newId = uid();
        state.items.push({ id: newId, name, lisNumber, createdAt: now });
        
        // Add initial hours if provided
        if (initialHours > 0) {
          if (!state.adj[newId]) state.adj[newId] = 0;
          state.adj[newId] = initialHours;
          saveAdj();
        }
      }
      save();
      clearForm();
      render();
    }

    function deleteItem(id){
      const item = state.items.find(x => x.id === id);
      const label = item ? `${item.name}` : '#'+id;
      if (!confirm(`Delete ${label}? This cannot be undone.`)) return;
      state.items = state.items.filter(x => x.id !== id);
      save();
      if (state.editingId === id) clearForm();
      render();
    }

    function clearAll(){
      if (!state.items.length) return;
      if (!confirm('Clear ALL entries? This cannot be undone.')) return;
      state.items = [];
      state.hours = {};
      state.adj = {};
      state.excluded = {};
      state.shifts = {};
      state.refusals = {};
      state.locationCount = DEFAULT_LOCATION_COUNT;
      save();
      saveHours();
      saveAdj();
      saveExclusions();
      saveShifts();
      saveRefusals();
      saveLocationConfig();
      // Also clear any corrupted last change data
      try {
        const keys = Object.keys(localStorage).filter(k => k.startsWith('ot_last_change_v1::'));
        keys.forEach(k => localStorage.removeItem(k));
      } catch(e) {}
      clearForm();
      render();
    }

    function setSort(key){
      state.useRankOrder = false; // respect manual sort when user clicks headers
      if (state.sort.key === key){
        state.sort.dir = state.sort.dir === 'asc' ? 'desc' : 'asc';
      } else {
        state.sort.key = key; state.sort.dir = 'asc';
      }
      render();
    }

    function sortedAndFiltered(){
      const q = state.filter.toLowerCase();
      let rows = state.items
        .map((x, i) => ({ ...x, index: i+1 }))
        .filter(r => !q || r.name.toLowerCase().includes(q) || (r.lisNumber || '').toLowerCase().includes(q));

      if (state.useRankOrder){
        rows.sort(compareByWhosNext);
      } else {
        const { key, dir } = state.sort;
        const cmp = (a,b) => {
          if (key === 'lisNumber' || key === 'index'){
            const na = Number(a[key]); const nb = Number(b[key]);
            const A = Number.isFinite(na) ? na : Number.POSITIVE_INFINITY;
            const B = Number.isFinite(nb) ? nb : Number.POSITIVE_INFINITY;
            return A - B;
          }
          const A = (a[key] ?? '').toString().toLowerCase();
          const B = (b[key] ?? '').toString().toLowerCase();
          if (A < B) return -1; if (A > B) return 1; return 0;
        };
        rows.sort(cmp);
        if (dir === 'desc') rows.reverse();
      }
      return rows;
    }

    function render(){
      // Debug: console.log('🔄 MAIN RENDER FUNCTION CALLED');
      // Update header (month picker + mode)
      // Mode pill is optional in current UI; update only if present
      if (el.modePill) el.modePill.textContent = IS_ADMIN ? 'Admin' : 'Read-only';
      if (el.adminSwitch) el.adminSwitch.checked = !!IS_ADMIN; // Visual-only admin switch reflects state
      const mpv = `${state.viewYear}-${String(state.viewMonth1).padStart(2,'0')}`;
      if (el.monthPicker.value !== mpv) el.monthPicker.value = mpv;

      const rows = sortedAndFiltered();
      // Update read-only month badges
      const monthLabel = new Date(state.viewYear, state.viewMonth1-1, 1).toLocaleDateString(undefined, { month:'long', year:'numeric' });
      const tableMonthPill = document.getElementById('tableMonthPill');
      if (tableMonthPill) tableMonthPill.textContent = monthLabel;
      const weekends = getWeekendColumns(state.viewYear, state.viewMonth1);
      renderColgroups(weekends);
      renderOvertimeHeader(weekends);

      const frag = document.createDocumentFragment();
      const colTotals = new Map(); // dateKey -> sum
      
      // Pre-filter rows to remove any obviously corrupted data before rendering
      const validRows = rows.filter(r => {
        if (!r || !r.id) return false;
        const name = String(r.name || '').trim();
        if (!name || /^\d+$/.test(name)) return false;
        if (name.toLowerCase().includes('fri') || name.toLowerCase().includes('sat') || 
            name.toLowerCase().includes('sun') || name.toLowerCase().includes('mon')) return false;
        return true;
      });
      
      console.log(`Rendering ${validRows.length} valid rows out of ${rows.length} total`);
      
      validRows.forEach(r => {
        const tr = document.createElement('tr');
        const cells = [];
        // Validate data before rendering to prevent corruption
        const safeName = String(r.name || '').trim() || 'Invalid Name';
        const safeListNum = String(r.lisNumber || '').trim();
        
        // Skip rows with obviously corrupted data
        if (/^\d+$/.test(safeName) || safeName.toLowerCase().includes('fri') || safeName.toLowerCase().includes('sat')) {
          console.warn('Skipping corrupted row:', r);
          return; // Skip this iteration entirely
        }
        
        // Sticky left columns: list, name
        cells.push(`<td class="col-list num">${escapeHtml(safeListNum)}</td>`);
        // Add title tooltip so very long names are still fully readable on hover
        cells.push(`<td class="col-name name-cell" title="${escapeHtml(safeName)}">${escapeHtml(safeName)}</td>`);

        // BaseSum: sum ALL hours for this person (cumulative across all months)
        let baseSumAll = baseSum(r.id); // This is the cumulative total
        let baseSumMonth = 0; // This is just for the current month display
        
        weekends.forEach(w => {
          const currentWeekendKey = getWeekendKey(w.days[0].date);
          
          // Render 5 shift columns instead of 4 date columns
          const shifts = [
            'shift1_fri_sat',
            'shift2_sat_afternoon', 
            'shift3_sat_night',
            'shift4_sun_morning',
            'shift5_2_to_finish'
          ];
          
          shifts.forEach(shiftCode => {
            const shiftHours = getShiftHours(r.id, shiftCode, currentWeekendKey);
            if (shiftHours > 0) {
              baseSumMonth += shiftHours;
              // Add to column totals using shift code as key
              colTotals.set(shiftCode, (colTotals.get(shiftCode) || 0) + shiftHours);
            }
            cells.push(renderShiftHourCell(r.id, shiftCode, currentWeekendKey));
          });
        });

        // Total hours for display (includes all hours + adjustments + refusal penalties)
        const cumulativeTotal = effectiveTotal(r.id);
        const totalDisplay = cumulativeTotal ? cumulativeTotal.toFixed(2).replace(/\.00$/, '') : '';
        cells.push(`<td class="right row-total-cell" data-person="${r.id}">
          <input class="row-total-input" type="number" inputmode="decimal" min="-100000" max="1000000" step="0.25" autocomplete="off" enterkeyhint="done" placeholder="0 hrs" value="${totalDisplay}" data-person="${r.id}" aria-describedby="totalHelp" title="Edit cumulative total hours (includes all months) - system will calculate adjustment" />
        </td>`);
        cells.push(`<td class="right td-actions">
            <div class="btn-group">
              <button class="secondary" title="Edit" data-action="edit" data-id="${r.id}">Edit</button>
              <button class="danger" title="Delete" data-action="delete" data-id="${r.id}">Delete</button>
            </div>
          </td>`);
        // Render all rows without cell count validation
        tr.innerHTML = cells.join('');
        frag.appendChild(tr);
      });
      // Clear tbody before adding new content
      el.tbody.innerHTML = '';
      el.tbody.appendChild(frag);

      renderTotalsRow(weekends, colTotals);

      // Update sort indicators
      document.querySelectorAll('th.sortable').forEach(th => {
        const dir = th.querySelector('.dir');
        if (!dir) return;
        const key = th.getAttribute('data-key');
        dir.textContent = (key === state.sort.key) ? (state.sort.dir === 'asc' ? '▲' : '▼') : '';
      });

      const count = state.items.length;
      el.countPill.textContent = count === 1 ? '1 entry' : `${count} entries`;
      // Collapse Add/Edit by default when >=1 entry; purely visual
      if (el.entryCard) el.entryCard.setAttribute('data-collapsed', count >= 1 ? 'true' : 'false');

      renderWhosNext();
    }

    // Insert colgroups with fixed widths to stabilize layout
    function renderColgroups(weekends){
      const table = el.table;
      // Remove existing colgroups
      table.querySelectorAll('colgroup').forEach(cg => cg.remove());
      const cgFixed = document.createElement('colgroup');
      cgFixed.className = 'fixed';
      cgFixed.innerHTML = '<col class="col-list"><col class="col-name"><col class="col-pass">';
      table.insertBefore(cgFixed, el.thead);
      const cgShifts = document.createElement('colgroup');
      cgShifts.className = 'shifts';
      const cols = [];
      weekends.forEach(w => {
        // 5 shift columns per weekend
        for (let i = 0; i < 5; i++) {
          cols.push('<col class="col-shift">');
        }
      });
      cgShifts.innerHTML = cols.join('');
      table.insertBefore(cgShifts, el.thead);
      const cgRight = document.createElement('colgroup');
      cgRight.className = 'fixed-right';
      cgRight.innerHTML = '<col class="col-total"><col class="col-actions">';
      table.insertBefore(cgRight, el.thead);
    }

    function renderHourCell(personId, dateKeyStr, val){
      // Check if this date has a shift assignment
      const currentWeekendKey = getCurrentWeekendKey();
      const personShifts = getPersonShifts(personId, currentWeekendKey);
      const shiftForDate = getShiftForDate(personShifts, dateKeyStr);
      
      if (shiftForDate) {
        return renderShiftCell(personId, dateKeyStr, shiftForDate, currentWeekendKey);
      } else {
        return renderShiftSelector(personId, dateKeyStr, currentWeekendKey);
      }
    }

    // Render shift-based hour input cell
    function renderShiftHourCell(personId, shiftCode, currentWeekendKey){
      const disabled = IS_ADMIN ? '' : 'disabled';
      const shiftDef = SHIFT_DEFINITIONS[shiftCode];
      
      if (!shiftDef) {
        return `<td class="shift-hour-cell"><input type="number" value="0" disabled /></td>`;
      }
      
      // Get current hours and refusal status for this shift
      const currentHours = getShiftHours(personId, shiftCode, currentWeekendKey);
      const displayValue = currentHours > 0 ? displayHours(currentHours) : '';
      const refusalDetails = getShiftRefusalDetails(personId, shiftCode, currentWeekendKey);
      const isRefused = refusalDetails?.refused || false;
      const didWork = refusalDetails?.worked || false;
      
      // Determine CSS class and title based on refusal status
      let cssClass = '';
      let title = '';
      
      if (isRefused && didWork) {
        cssClass = ' refused-worked';
        title = `REFUSED BUT WORKED: ${shiftDef.name} (${currentHours}h - disciplinary record)`;
      } else if (isRefused) {
        cssClass = ' refused';
        title = `REFUSED: ${shiftDef.name} (${currentHours}h charged but refused)`;
      } else {
        title = `Hours worked for ${shiftDef.name} (max ${shiftDef.chargeableHours}h)`;
      }
      
      // Admin controls for refused shifts
      let adminControls = '';
      if (IS_ADMIN && isRefused) {
        const workedChecked = didWork ? 'checked' : '';
        adminControls = `
          <div class="shift-admin-controls">
            <label title="Mark as worked despite refusal (disciplinary tracking)">
              <input type="checkbox" 
                     class="refused-worked-checkbox" 
                     data-person="${personId}" 
                     data-shift="${shiftCode}" 
                     data-weekend="${currentWeekendKey}" 
                     ${workedChecked} />
              Worked
            </label>
          </div>`;
      }
      
      return `<td class="shift-hour-cell${cssClass}" data-person="${personId}" data-shift="${shiftCode}" data-weekend="${currentWeekendKey}">
        <input type="number" 
               inputmode="decimal" 
               min="0" 
               max="${shiftDef.chargeableHours}" 
               step="0.25" 
               autocomplete="off" 
               enterkeyhint="done" 
               placeholder="0" 
               value="${displayValue}" 
               data-person="${personId}" 
               data-shift="${shiftCode}" 
               data-weekend="${currentWeekendKey}" 
               title="${title}"
               ${disabled} />
        ${adminControls}
      </td>`;
    }

    // Get hours worked for a specific shift
    function getShiftHours(personId, shiftCode, weekendKey){
      const shiftHoursKey = `shift-hours-v1`;
      let shiftHours = {};
      try {
        shiftHours = JSON.parse(localStorage.getItem(shiftHoursKey) || '{}');
      } catch(_) {}
      
      const personKey = `${personId}_${weekendKey}`;
      const personShiftHours = shiftHours[personKey] || {};
      return personShiftHours[shiftCode] || 0;
    }

    // Set hours worked for a specific shift
    function setShiftHours(personId, shiftCode, weekendKey, hours){
      const shiftHoursKey = `shift-hours-v1`;
      let shiftHours = {};
      try {
        shiftHours = JSON.parse(localStorage.getItem(shiftHoursKey) || '{}');
      } catch(_) {}
      
      const personKey = `${personId}_${weekendKey}`;
      if (!shiftHours[personKey]) shiftHours[personKey] = {};
      
      if (hours == null || hours <= 0) {
        delete shiftHours[personKey][shiftCode];
        // Clean up empty person entries
        if (Object.keys(shiftHours[personKey]).length === 0) {
          delete shiftHours[personKey];
        }
        
        // If hours are being set to 0 for a refused shift, mark as not worked
        const refusalDetails = getShiftRefusalDetails(personId, shiftCode, weekendKey);
        if (refusalDetails && refusalDetails.refused) {
          refusalDetails.worked = false;
          refusalDetails.actualHours = 0;
          saveRefusals();
        }
      } else {
        shiftHours[personKey][shiftCode] = Number(hours);
        
        // If hours are being set for a refused shift, automatically mark as worked
        const refusalDetails = getShiftRefusalDetails(personId, shiftCode, weekendKey);
        if (refusalDetails && refusalDetails.refused) {
          refusalDetails.worked = true;
          refusalDetails.actualHours = Number(hours);
          saveRefusals();
        }
      }
      
      try {
        localStorage.setItem(shiftHoursKey, JSON.stringify(shiftHours));
      } catch(_) {}
    }
    
    // Set penalty hours for a refused shift (does NOT mark as worked)
    function setRefusalPenaltyHours(personId, shiftCode, weekendKey, hours){
      const shiftHoursKey = `shift-hours-v1`;
      let shiftHours = {};
      try {
        shiftHours = JSON.parse(localStorage.getItem(shiftHoursKey) || '{}');
      } catch(_) {}
      
      const personKey = `${personId}_${weekendKey}`;
      if (!shiftHours[personKey]) shiftHours[personKey] = {};
      
      if (hours > 0) {
        shiftHours[personKey][shiftCode] = Number(hours);
        // Note: We deliberately do NOT mark as worked for refusal penalties
      }
      
      try {
        localStorage.setItem(shiftHoursKey, JSON.stringify(shiftHours));
      } catch(_) {}
    }

    // Refusal tracking functions
    // Get refusal status for a specific shift
    function getShiftRefusal(personId, shiftCode, weekendKey){
      const refusalKey = `shift-refusals-v1`;
      let refusals = {};
      try {
        refusals = JSON.parse(localStorage.getItem(refusalKey) || '{}');
      } catch(_) {}
      
      const personKey = `${personId}_${weekendKey}`;
      const personRefusals = refusals[personKey] || {};
      return !!personRefusals[shiftCode];
    }

    // Set refusal status for a specific shift
    function setShiftRefusal(personId, shiftCode, weekendKey, isRefusal){
      const refusalKey = `shift-refusals-v1`;
      let refusals = {};
      try {
        refusals = JSON.parse(localStorage.getItem(refusalKey) || '{}');
      } catch(_) {}
      
      const personKey = `${personId}_${weekendKey}`;
      if (!refusals[personKey]) refusals[personKey] = {};
      
      if (isRefusal) {
        refusals[personKey][shiftCode] = true;
      } else {
        delete refusals[personKey][shiftCode];
        // Clean up empty person entries
        if (Object.keys(refusals[personKey]).length === 0) {
          delete refusals[personKey];
        }
      }
      
      try {
        localStorage.setItem(refusalKey, JSON.stringify(refusals));
      } catch(_) {}
    }

    // Clear refusal status for a specific shift
    function clearShiftRefusal(personId, shiftCode, weekendKey){
      setShiftRefusal(personId, shiftCode, weekendKey, false);
    }

    // Update the 'worked' status for a shift assignment based on refusal
    function updateShiftWorkedStatus(personId, shiftCode, weekendKey, isRefusal){
      const personData = state.shifts[weekendKey]?.[personId];
      if (!personData || !personData.shifts) return;
      
      // Find the shift assignment
      const shiftAssignment = personData.shifts.find(s => s.shiftCode === shiftCode);
      if (shiftAssignment) {
        shiftAssignment.worked = !isRefusal; // If it's a refusal, they didn't work it
        saveShifts();
      }
    }

    // Migrate existing shift data to include 'worked' field
    function migrateShiftWorkedStatus(){
      const migrationKey = 'shifts-worked-migration-v1';
      
      // Check if migration has already been done
      if (localStorage.getItem(migrationKey) === 'true') {
        return;
      }
      
      let migrated = false;
      
      // Go through all shift data and add 'worked' field where missing
      Object.keys(state.shifts).forEach(weekendKey => {
        const weekendData = state.shifts[weekendKey];
        Object.keys(weekendData).forEach(personId => {
          const personData = weekendData[personId];
          if (personData.shifts) {
            personData.shifts.forEach(shift => {
              if (shift.worked === undefined) {
                // Default to worked=true, then check if it was marked as refusal
                const isRefused = getShiftRefusal(personId, shift.shiftCode, weekendKey);
                shift.worked = !isRefused; // If refused, they didn't work it
                migrated = true;
              }
            });
          }
        });
      });
      
      if (migrated) {
        saveShifts();
        console.log('Migrated existing shift data to include worked status');
      }
      
      // Mark migration as completed
      localStorage.setItem(migrationKey, 'true');
    }

    // Migration function to convert old date-based hours to shift-based hours
    function migrateOldHoursToShifts(){
      const migrationKey = 'hours-migration-completed-v1';
      
      // Check if migration has already been done
      if (localStorage.getItem(migrationKey) === 'true') {
        console.log('Hours migration already completed');
        return { success: true, message: 'Migration already completed', alreadyDone: true };
      }
      
      let migratedCount = 0;
      let totalHoursMigrated = 0;
      const results = [];
      
      try {
        // Get all existing date-based hours
        const existingHours = state.hours || {};
        
        // Process each person's hours
        Object.keys(existingHours).forEach(personId => {
          const personHours = existingHours[personId];
          const personResults = { personId, weekends: [], totalHours: 0 };
          
          // Group dates by weekend to properly map to shifts
          const datesByWeekend = {};
          
          Object.keys(personHours).forEach(dateKey => {
            const date = new Date(dateKey + 'T12:00:00');
            const weekendKey = getWeekendKey(date);
            
            if (!datesByWeekend[weekendKey]) {
              datesByWeekend[weekendKey] = {};
            }
            datesByWeekend[weekendKey][dateKey] = personHours[dateKey];
          });
          
          // Process each weekend
          Object.keys(datesByWeekend).forEach(weekendKey => {
            const weekendHours = datesByWeekend[weekendKey];
            const weekendResult = { weekendKey, shifts: {}, totalHours: 0 };
            
            // Map hours to shifts based on date
            Object.keys(weekendHours).forEach(dateKey => {
              const hours = weekendHours[dateKey];
              if (hours <= 0) return;
              
              const date = new Date(dateKey + 'T12:00:00');
              const dayOfWeek = date.getDay(); // 0 = Sunday, 5 = Friday, 6 = Saturday
              
              // Map date to shift based on day of week
              let targetShift = null;
              if (dayOfWeek === 5) { // Friday
                targetShift = 'shift1_fri_sat';
              } else if (dayOfWeek === 6) { // Saturday
                // Split Saturday hours between Shift 2 and 3 (simple approach: all to Shift 2)
                targetShift = 'shift2_sat_afternoon';
              } else if (dayOfWeek === 0) { // Sunday  
                // Split Sunday hours between Shift 4 and 5 (simple approach: all to Shift 4)
                targetShift = 'shift4_sun_morning';
              } else if (dayOfWeek === 1) { // Monday
                targetShift = 'shift5_2_to_finish';
              }
              
              if (targetShift) {
                // Store in new shift-based system
                const currentShiftHours = getShiftHours(personId, targetShift, weekendKey);
                const newHours = currentShiftHours + hours;
                setShiftHours(personId, targetShift, weekendKey, newHours);
                
                weekendResult.shifts[targetShift] = newHours;
                weekendResult.totalHours += hours;
                totalHoursMigrated += hours;
              }
            });
            
            if (weekendResult.totalHours > 0) {
              personResults.weekends.push(weekendResult);
              personResults.totalHours += weekendResult.totalHours;
            }
          });
          
          if (personResults.totalHours > 0) {
            results.push(personResults);
            migratedCount++;
          }
        });
        
        // Mark migration as completed
        localStorage.setItem(migrationKey, 'true');
        
        console.log(`Migration completed: ${migratedCount} people, ${totalHoursMigrated} total hours migrated`);
        
        return {
          success: true,
          message: `Successfully migrated ${totalHoursMigrated} hours for ${migratedCount} people`,
          migratedCount,
          totalHoursMigrated,
          details: results
        };
        
      } catch (error) {
        console.error('Migration failed:', error);
        return {
          success: false,
          message: `Migration failed: ${error.message}`,
          error
        };
      }
    }

    // Check if a date has a shift assignment
    function getShiftForDate(personShifts, dateKey){
      if (!personShifts || !personShifts.shifts) return null;
      
      // Find shift that covers this date
      for (const shift of personShifts.shifts) {
        const shiftDef = SHIFT_DEFINITIONS[shift.shiftCode];
        if (doesShiftCoverDate(shiftDef, dateKey)) {
          return shift;
        }
      }
      return null;
    }

    // Check if a shift covers a specific date
    function doesShiftCoverDate(shiftDef, dateKey){
      const targetDate = new Date(dateKey + 'T12:00:00'); // Noon on the date
      const weekend = getCurrentWeekend();
      const shiftDates = calculateShiftDates(shiftDef, weekend);
      const shiftStart = new Date(shiftDates.start);
      const shiftEnd = new Date(shiftDates.end);
      
      // Check if date falls within shift period (considering overnight shifts)
      return targetDate >= new Date(shiftStart.toDateString()) && 
             targetDate <= new Date(shiftEnd.toDateString());
    }

    // Render cell with assigned shift
    function renderShiftCell(personId, dateKey, shiftData, weekendKey){
      const shiftDef = SHIFT_DEFINITIONS[shiftData.shiftCode];
      const disabled = IS_ADMIN ? '' : 'disabled';
      
      return `<td class="shift-cell" data-person="${personId}" data-date="${dateKey}" title="${shiftDef.name}">
        <div class="shift-display">
          <div class="shift-info">
            <div class="shift-hours">${shiftDef.chargeableHours}h</div>
            <div class="shift-time">${shiftDef.display}</div>
            ${shiftDef.special ? '<div class="shift-badge">2 to Finish</div>' : ''}
          </div>
          <div class="shift-breakdown" title="Regular: ${shiftDef.regularHours}h | OT: ${shiftDef.overtimeHours}h | Chargeable: ${shiftDef.chargeableHours}h">
            ${shiftDef.regularHours > 0 ? `<span class="regular-hours">${shiftDef.regularHours}R</span>` : ''}
            <span class="ot-hours">${shiftDef.chargeableHours}OT</span>
          </div>
        </div>
        ${!disabled ? `<button class="remove-shift" data-person="${personId}" data-shift="${shiftData.shiftCode}" data-weekend="${weekendKey}" title="Remove shift">×</button>` : ''}
      </td>`;
    }

    // Render cell with shift selector
    function renderShiftSelector(personId, dateKey, weekendKey){
      const disabled = IS_ADMIN ? '' : 'disabled';
      const availableShifts = getAvailableShiftsForDate(dateKey, weekendKey);
      
      if (disabled || availableShifts.length === 0) {
        return `<td class="shift-cell" data-person="${personId}" data-date="${dateKey}">
          <div class="shift-display">--</div>
        </td>`;
      }
      
      const options = availableShifts.map(shift => {
        const eligibility = canWorkShift(personId, shift.code, weekendKey);
        const eligibleClass = eligibility.eligible ? '' : ' class="ineligible"';
        const title = eligibility.eligible ? '' : ` title="${eligibility.reason}"`;
        return `<option value="${shift.code}"${eligibleClass}${title}>${shift.shortDisplay} (${shift.chargeableHours}h)</option>`;
      }).join('');
      
      return `<td class="shift-cell" data-person="${personId}" data-date="${dateKey}">
        <select class="shift-selector" data-person="${personId}" data-date="${dateKey}" data-weekend="${weekendKey}">
          <option value="">Select Shift</option>
          ${options}
        </select>
      </td>`;
    }

    // Get available shifts for a specific date
    function getAvailableShiftsForDate(dateKey, weekendKey){
      return Object.values(SHIFT_DEFINITIONS).filter(shift => {
        return doesShiftCoverDate(shift, dateKey) && !isShiftAtCapacity(shift.code, weekendKey);
      });
    }

    // Check if a shift is already assigned to someone (only counts actually worked shifts)
    function isShiftAssigned(shiftCode, weekendKey){
      const assignments = state.shifts[weekendKey] || {};
      for (const personId in assignments) {
        const personShifts = assignments[personId].shifts || [];
        if (personShifts.some(s => s.shiftCode === shiftCode && s.worked === true)) {
          return true;
        }
      }
      return false;
    }

    function renderTotalsRow(weekends, colTotals){
      const parts = [];
      parts.push('<tr>');
      parts.push('<td class="col-list"></td>'); // List #
      parts.push('<td class="col-name muted" style="font-weight: 700;">Column Totals</td>'); // Name label
      let grand = 0;
      weekends.forEach(w => {
        w.days.forEach(day => {
          const k = dateKey(day.date);
          const v = colTotals.get(k) || 0;
          grand += v;
          parts.push(`<td class="right muted num" title="Column total: ${v ? v.toFixed(2).replace(/\\.00$/, '') + ' hours' : '0 hours'}">${v ? v.toFixed(2).replace(/\\.00$/, '') : ''}</td>`);
        });
      });
      parts.push(`<td class="right num" title="Month total: ${grand ? grand.toFixed(2) + ' hours for this month only' : '0 hours for this month'}">${grand ? grand.toFixed(2).replace(/\\.00$/, '') : ''}</td>`);
      parts.push('<td class="td-actions"><small style="opacity: 0.7;">This Month Only</small></td>');
      parts.push('</tr>');
      el.tfoot.innerHTML = parts.join('');
    }

    // ==== Who's Next panel (shift-aware live ranking) ====
    // Computes live ranking for current weekend with shift eligibility
    function renderWhosNext(){
      const mk = monthKey();
      const currentWeekendKey = getCurrentWeekendKey();
      const nextShift = getNextAvailableShift(currentWeekendKey);
      
      // Render weekend capacity summary
      renderWeekendSummary(currentWeekendKey);
      
      el.wnMonthPill.textContent = new Date(state.viewYear, state.viewMonth1-1, 1).toLocaleDateString(undefined, { month:'long', year:'numeric' });
      const query = (state.wnQuery || '').trim().toLowerCase();
      const rows = state.items.slice();
      
      // Filter out excluded people and add shift eligibility info
      const ranked = rows.map(p => {
        const total = effectiveTotal(p.id);
        const last = getLastChange(p.id);
        const excluded = isPersonExcluded(p.id, currentWeekendKey);
        const personShifts = getPersonShifts(p.id, currentWeekendKey);
        const weekendHours = personShifts ? personShifts.chargeableHours : 0;
        const eligibility = nextShift ? canWorkShift(p.id, nextShift.code, currentWeekendKey) : { eligible: false, reason: 'No shifts available' };
        
        return { 
          id: p.id, 
          name: p.name || '', 
          lis: p.lisNumber || '', 
 
          total, 
          last, 
          excluded,
          weekendHours,
          eligible: eligibility.eligible && !excluded,
          ineligibleReason: excluded ? 'Excluded for this weekend' : eligibility.reason
        };
      }).filter(r => {
        // Filter by search query
        if (query && !(r.name.toLowerCase().includes(query) || String(r.lis).toLowerCase().includes(query) || String(r.pass).toLowerCase().includes(query))) {
          return false;
        }
        return true; // Show all, but mark eligibility
      }).sort((a,b) => {
        // Sort eligible people first
        if (a.eligible && !b.eligible) return -1;
        if (!a.eligible && b.eligible) return 1;
        
        // Then by total hours (least first)
        if (a.total !== b.total) return a.total - b.total;
        if (a.last !== b.last) return a.last - b.last;
        const an = Number(a.lis), bn = Number(b.lis);
        if (!Number.isNaN(an) && !Number.isNaN(bn) && an !== bn) return an - bn;
        if (String(a.lis) !== String(b.lis)) return String(a.lis).localeCompare(String(b.lis));
        return a.name.localeCompare(b.name);
      });

      const frag = document.createDocumentFragment();
      ranked.forEach((r, i) => {
        const row = document.createElement('div');
        row.className = `wn-item ${!r.eligible ? 'ineligible' : ''}`;
        
        const nextShiftDisplay = nextShift ? `${nextShift.shortDisplay} (${nextShift.chargeableHours}h)` : 'No shifts available';
        
        // Get active shifts for the current weekend/location
        const activeShifts = getActiveShiftsForWeekend(currentWeekendKey);
        const shiftsHtml = activeShifts.length === 0 
          ? '<div class="shifts-empty">No shifts configured</div>'
          : activeShifts.map(shift => {
              // Get Accept OT button state for this person/shift
              const acceptState = getAcceptOTButtonState(r.id, shift.code, currentWeekendKey);
              
              // Show remaining slots badge
              const remainingBadge = shift.remaining > 0 && shift.remaining < shift.capacity
                ? `<span class="shift-badge">${shift.remaining}</span>`
                : '';
              
              // Get Refusal button state for this person/shift
              const refusalState = getRefusalButtonState(r.id, shift.code, currentWeekendKey);
              
              return `
                <div class="shift-btn-group">
                  <button 
                    class="accept-ot-btn ${acceptState.cssClass}" 
                    data-person-id="${r.id}" 
                    data-shift-code="${shift.code}"
                    data-weekend-key="${currentWeekendKey}"
                    data-action="accept-ot"
                    title="${acceptState.title}"
                    aria-label="${acceptState.title}"
                    ${acceptState.disabled ? 'disabled' : ''}
                  >
                    ${acceptState.state === 'assigned' ? `✓ ${shift.shortDisplay}` : `Accept ${shift.shortDisplay}`}${acceptState.state === 'available' ? remainingBadge : ''}
                  </button>
                  <button 
                    class="${refusalState.cssClass}" 
                    data-person-id="${r.id}" 
                    data-shift-code="${shift.code}"
                    data-weekend-key="${currentWeekendKey}"
                    data-action="refuse"
                    title="${refusalState.title}"
                    aria-label="${refusalState.title}"
                    ${refusalState.disabled ? 'disabled' : ''}
                  >
                    ${refusalState.state === 'refused' ? `✗ ${shift.shortDisplay}` : `Refuse ${shift.shortDisplay}`}
                  </button>
                </div>
              `;
            }).join('');
        
        row.innerHTML = `
          <div class="wn-rank" title="Rank">${i+1}</div>
          <div class="wn-main">
            <div class="wn-left">
              <div class="wn-text">
                <div class="wn-name" title="${escapeHtml(r.name)}">${escapeHtml(r.name)}</div>
                <div class="wn-meta">${escapeHtml(r.lis)} • ${escapeHtml(r.pass)}</div>
              </div>
            </div>
            <div class="wn-right">
              <div class="num" title="Cumulative hours across all months">${displayHours(r.total)} hrs total</div>
              <div class="weekend-hours">${r.weekendHours}h this weekend</div>
              ${!r.eligible ? `<div class="ineligible-reason">${r.ineligibleReason}</div>` : ''}
            </div>
          </div>
          <div class="wn-buttons">
            ${r.excluded ? 
              // Show restore button for excluded people
              `<button class="wn-btn secondary restore-person" data-person-id="${r.id}" title="Restore to Who's Next list">
                Restore
              </button>` :
              // Show Not Here button only
                `<button class="wn-btn not-here" data-person-id="${r.id}" data-action="nothere" title="Mark as not available for this weekend">Not Here</button>`
            }
          </div>
          <div class="wn-shifts">
            ${shiftsHtml}
          </div>
        `;
        
        // Only add click-to-scroll on the main area, not the buttons
        const mainArea = row.querySelector('.wn-main');
        mainArea.style.cursor = 'pointer';
        mainArea.addEventListener('click', () => scrollToPerson(r.id));
        
        frag.appendChild(row);
      });
      
      el.wnList.replaceChildren(frag);
    }

    function scrollToPerson(personId){
      const tr = Array.from(el.tbody.querySelectorAll('tr')).find(tr => tr.querySelector(`button[data-id="${personId}"]`));
      if (tr){
        tr.scrollIntoView({ behavior:'smooth', block:'center' });
        const nameCell = tr.querySelector('.col-name') || tr.children[1];
        if (nameCell){ nameCell.classList.add('pulse'); setTimeout(()=> nameCell.classList.remove('pulse'), 1300); }
      }
    }



    function escapeHtml(str){
      // Extra safety: ensure we're working with a string and strip any weird characters
      const safe = String(str || '').replace(/[\r\n\t]/g, ' ').replace(/\s+/g, ' ').trim();
      return safe.replace(/[&<>"]?/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[s] || s));
    }

    function exportCsv(){
      const header = ['List #','Name','Hours'];
      const lines = [header.join(',')];
      state.items.forEach(x => {
        const hours = effectiveTotal(x.id) || 0;
        const row = [csvCell(x.lisNumber || ''), csvCell(x.name), csvCell(hours.toString())].join(',');
        lines.push(row);
      });
      const blob = new Blob(["\uFEFF" + lines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      triggerDownload(blob, 'pass-list.csv');
    }

    function csvCell(v){
      const s = (v ?? '').toString();
      if (/[",\n]/.test(s)) return '"' + s.replace(/"/g,'""') + '"';
      return s;
    }

    function exportJson(){
      const blob = new Blob([JSON.stringify(state.items, null, 2)], { type: 'application/json' });
      triggerDownload(blob, 'pass-list.json');
    }

    function triggerDownload(blob, filename){
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
    document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }

    async function importFile(file){
      if (!file) return;
      const text = await file.text();
      let imported = [];
      try {
        if (file.type.includes('json') || text.trim().startsWith('[')){
          const arr = JSON.parse(text);
          if (Array.isArray(arr)) imported = arr.map(x => ({ id: x.id || uid(), name: normalize(x.name), lisNumber: normalize(x.lisNumber), initialHours: parseFloat(x.hours) || 0, createdAt: x.createdAt || new Date().toISOString() }));
        } else {
          imported = parseCsv(text);
        }
      } catch(e){ alert('Could not parse file. Make sure it is valid CSV or JSON.'); return; }

      if (!imported.length){ alert('No entries found in file.'); return; }
      const merged = mergeByIdOrLis(state.items, imported);
      const addCount = merged.length - state.items.length;
      state.items = merged;
      save();
      saveAdj(); // Save hour adjustments from import
      render();
      alert(`Imported ${imported.length} rows (${addCount} new, ${imported.length - addCount} updated/merged).`);
    }

    function mergeByIdOrLis(existing, incoming){
      const byId = new Map(existing.map(x => [x.id, x]));
      const byLis = new Map(existing.map(x => [((x.lisNumber || '').toLowerCase()), x]));
      incoming.forEach(n => {
        const keyLis = (n.lisNumber || '').toLowerCase();
        const match = (n.id && byId.get(n.id)) || (keyLis && byLis.get(keyLis));
        if (match){ 
          // Update existing item
          Object.assign(match, { name: n.name || match.name, lisNumber: n.lisNumber ?? match.lisNumber, updatedAt: new Date().toISOString() });
          // Update hours if provided
          if (n.initialHours > 0) {
            const currentTotal = effectiveTotal(match.id);
            const adjustment = n.initialHours - currentTotal;
            if (adjustment !== 0) {
              if (!state.adj[match.id]) state.adj[match.id] = 0;
              state.adj[match.id] += adjustment;
            }
          }
        } else { 
          // Create new item
          const newId = n.id || uid();
          existing.push({ id: newId, name: n.name || '', lisNumber: n.lisNumber || '', createdAt: new Date().toISOString() });
          // Add initial hours if provided
          if (n.initialHours > 0) {
            if (!state.adj[newId]) state.adj[newId] = 0;
            state.adj[newId] = n.initialHours;
          }
        }
      });
      return existing;
    }

    function parseCsv(text){
      // CSV parser: supports 2 or 3 columns
      const lines = text.split(/\r?\n/).filter(l => l.trim().length);
      if (!lines.length) return [];
      // Detect header and column order
      const first = lines[0];
      const firstLower = first.toLowerCase();
      const hasHeader = firstLower.includes('name') && (firstLower.includes('lis') || firstLower.includes('list') || firstLower.includes('hour'));
      const headerCells = hasHeader ? smartSplitCsv(firstLower) : [];
      const colIndex = {
        name: hasHeader ? headerCells.findIndex(c => c.includes('name')) : 0,
        lis: hasHeader ? headerCells.findIndex(c => (c.includes('lis') || c.includes('list'))) : 1,
        hours: hasHeader ? headerCells.findIndex(c => c.includes('hour')) : 2,
      };
      const start = hasHeader ? 1 : 0;
      const rows = [];
      for (let i = start; i < lines.length; i++){
        const cells = smartSplitCsv(lines[i]);
        if (!cells.length) continue;
        let name, lisNumber, initialHours;
        if (hasHeader){
          name = cells[colIndex.name] ?? '';
          lisNumber = colIndex.lis >= 0 ? (cells[colIndex.lis] ?? '') : '';
          initialHours = colIndex.hours >= 0 ? parseFloat(cells[colIndex.hours]) || 0 : 0;
        } else {
          // Without header: support [Name, LIS, Hours] or [Name, LIS] or just [Name]
          if (cells.length >= 3){ [name, lisNumber, initialHours] = [cells[0], cells[1], parseFloat(cells[2]) || 0]; }
          else if (cells.length >= 2){ [name, lisNumber] = cells; initialHours = 0; }
          else { name = cells[0] || ''; lisNumber = ''; initialHours = 0; }
        }
        if (!name && !lisNumber) continue;
        rows.push({ id: uid(), name: normalize(name), lisNumber: normalize(lisNumber), initialHours, createdAt: new Date().toISOString() });
      }
      return rows;
    }

    function smartSplitCsv(line){
      const out = [];
      let cur = '';
      let inQuotes = false;
      for (let i=0; i<line.length; i++){
        const ch = line[i];
        if (inQuotes){
          if (ch === '"' && line[i+1] === '"'){ cur += '"'; i++; }
          else if (ch === '"'){ inQuotes = false; }
          else { cur += ch; }
        } else {
          if (ch === ','){ out.push(cur); cur = ''; }
          else if (ch === '"'){ inQuotes = true; }
          else { cur += ch; }
        }
      }
      out.push(cur);
      return out.map(s => s.trim());
    }

    // ===== Overtime helpers =====
    // Normalize and format hour values for storage and display
    function normalizeHours(raw){
      const n = Math.max(0, Math.min(24, Number(raw) || 0));
      return Math.round(n * 4) / 4; // round to nearest quarter hour
    }
    function displayHours(n){
      if (n == null) return '';
      const s = (Math.round(n * 100) / 100).toFixed(2).replace(/\.00$/, '');
      return s;
    }
    function monthKey(){ return `${state.viewYear}-${String(state.viewMonth1).padStart(2,'0')}`; }
    function visibleDateKeys(){
      const weekends = getWeekendColumns(state.viewYear, state.viewMonth1);
      const keys = [];
      weekends.forEach(w => w.days.forEach(d => keys.push(dateKey(d.date))));
      return keys;
    }
    function baseSum(personId){
      // Sum ALL hours across ALL dates, not just current month
      let sum = 0;
      const personHours = state.hours[personId] || {};
      
      // Check if migration has been completed
      const migrationCompleted = localStorage.getItem('hours-migration-completed-v1') === 'true';
      
      if (migrationCompleted) {
        // After migration, exclude old date-based hours to prevent double-counting
        // Only count hours from dates that aren't part of Friday-Monday weekends
        Object.keys(personHours).forEach(dateKey => {
          const v = personHours[dateKey];
          if (typeof v === 'number') {
            const date = new Date(dateKey + 'T12:00:00');
            const dayOfWeek = date.getDay(); // 0 = Sunday, 5 = Friday, 6 = Saturday, 1 = Monday
            
            // Only count hours from non-weekend days (Tuesday, Wednesday, Thursday)
            if (dayOfWeek >= 2 && dayOfWeek <= 4) {
              sum += v;
            }
          }
        });
      } else {
        // Before migration, count all hours normally
        Object.keys(personHours).forEach(dateKey => {
          const v = personHours[dateKey];
          if (typeof v === 'number') sum += v;
        });
      }
      
      return normalizeQuarter(sum);
    }
    
    function baseSumCurrentMonth(personId){
      // Sum only hours for currently visible month (for display purposes)
      const keys = visibleDateKeys();
      let sum = 0;
      keys.forEach(k => { const v = getHours(personId, k); if (typeof v === 'number') sum += v; });
      return normalizeQuarter(sum);
    }
    // Parse list number and determine provisional status
    function parseListNumber(lisNumber) {
      if (!lisNumber || typeof lisNumber !== 'string') {
        return { number: 99999, isProvisional: false };
      }
      
      const trimmed = lisNumber.trim();
      const isProvisional = trimmed.toLowerCase().startsWith('p');
      
      if (isProvisional) {
        // Remove 'P' or 'p' prefix and parse the remaining number
        const numberPart = trimmed.substring(1).trim();
        const parsed = parseInt(numberPart);
        return { 
          number: isNaN(parsed) ? 99999 : parsed,
          isProvisional: true 
        };
      } else {
        const parsed = parseInt(trimmed);
        return { 
          number: isNaN(parsed) ? 99999 : parsed,
          isProvisional: false 
        };
      }
    }

    function effectiveTotal(personId){
      const base = baseSum(personId); // Legacy hour-based system
      const shiftTotal = calculatePersonShiftTotal(personId); // New shift-based system
      const adj = Number(state.adj[personId] || 0);
      return normalizeQuarter(base + shiftTotal + adj);
    }
    // Comparator: same ordering as Who's Next panel (least -> most hours with tie-breakers)
    function compareByWhosNext(a, b){
      const at = effectiveTotal(a.id);
      const bt = effectiveTotal(b.id);
      
      // Primary sort: by hours (lowest first)
      if (at !== bt) return at - bt;
      
      // Secondary sort: by last change time
      const al = getLastChange(a.id);
      const bl = getLastChange(b.id);
      if (al !== bl) return al - bl;
      
      // Tertiary sort: by seniority (list number), with provisional treated as lowest seniority
      const aListInfo = parseListNumber(a.lisNumber);
      const bListInfo = parseListNumber(b.lisNumber);
      
      // If one is provisional and other isn't, provisional goes after (lower seniority)
      if (aListInfo.isProvisional && !bListInfo.isProvisional) return 1;  // a goes after b
      if (!aListInfo.isProvisional && bListInfo.isProvisional) return -1; // a goes before b
      
      // If both have same provisional status, compare by list numbers
      if (aListInfo.number !== bListInfo.number) return aListInfo.number - bListInfo.number;
      
      // Fall back to string comparison and name comparison
      if (String(a.lisNumber) !== String(b.lisNumber)) return String(a.lisNumber).localeCompare(String(b.lisNumber));
      return (a.name || '').localeCompare(b.name || '');
    }
    // Last change tracking per month for tie-breakers
    function loadLastChangeFor(month){
      try { return JSON.parse(localStorage.getItem(`ot_last_change_v1::${month}`) || '{}') || {}; } catch(_) { return {}; }
    }
    function saveLastChangeFor(month, obj){
      try { localStorage.setItem(`ot_last_change_v1::${month}`, JSON.stringify(obj)); } catch(_) {}
    }
    function bumpLastChange(personId){
      const mk = monthKey();
      const map = loadLastChangeFor(mk);
      map[personId] = Date.now();
      saveLastChangeFor(mk, map);
    }
    function getLastChange(personId){
      const mk = monthKey();
      const map = loadLastChangeFor(mk);
      return Number(map[personId] || 0);
    }
    // General quarter-hour rounding helper
    function normalizeQuarter(n){ return Math.round((Number(n) || 0) * 4) / 4; }
    // Clamp row total (manual adj) to safe bounds
    function clampTotal(n){
      const min = -100000, max = 1000000;
      return Math.max(min, Math.min(max, Number(n) || 0));
    }
    function updateTotalsFor(personId){
      // Calculate total including shift hours and all adjustments (including refusal penalties)
      const newTotal = effectiveTotal(personId);
      
      const cell = document.querySelector(`input.row-total-input[data-person="${personId}"]`);
      
      console.log(`Updating totals for person ${personId}:`);
      console.log(`- New total: ${newTotal}`);
      console.log(`- Cell found:`, cell ? 'YES' : 'NO');
      
      if (cell) {
        const oldValue = cell.value;
        cell.value = newTotal ? displayHours(newTotal) : '';
        console.log(`- Changed from ${oldValue} to ${cell.value}`);
      } else {
        console.warn(`Could not find input field for person ${personId}`);
      }

      // Recalc column totals and redraw footer
      const colTotals = new Map();
      const rows = sortedAndFiltered();
      const weekends = getWeekendColumns(state.viewYear, state.viewMonth1);
      
      rows.forEach(r => {
        weekends.forEach(w => w.days.forEach(day => {
          const k = dateKey(day.date);
          // Get hours from shifts or legacy hour system
          const shiftHours = getShiftHoursForDate(r.id, k);
          const legacyHours = getHours(r.id, k);
          const totalHours = shiftHours || (typeof legacyHours === 'number' ? legacyHours : 0);
          
          if (totalHours > 0) {
            colTotals.set(k, (colTotals.get(k) || 0) + totalHours);
          }
        }));
      });
      renderTotalsRow(weekends, colTotals);
      renderWhosNext(); // keep Who's Next live without full render
    }

    // Calculate total chargeable hours from all shifts for a person
    function calculatePersonShiftTotal(personId){
      let total = 0;
      let refusedButWorkedTotal = 0;
      
      // Sum shift hours across all weekends
      const shiftHoursKey = `shift-hours-v1`;
      let shiftHours = {};
      try {
        shiftHours = JSON.parse(localStorage.getItem(shiftHoursKey) || '{}');
      } catch(_) {}
      
      // Look for all entries for this person across all weekends
      Object.keys(shiftHours).forEach(personWeekendKey => {
        if (personWeekendKey.startsWith(personId + '_')) {
          // Extract weekend key from personWeekendKey (format: personId_weekendKey)
          const weekendKey = personWeekendKey.substring(personId.length + 1);
          
          const personShiftHours = shiftHours[personWeekendKey];
          Object.keys(personShiftHours).forEach(shiftCode => {
            const hours = Number(personShiftHours[shiftCode] || 0);
            
            // Check if this shift was refused but worked
            const refusalDetails = getShiftRefusalDetails(personId, shiftCode, weekendKey);
            if (refusalDetails && refusalDetails.refused && refusalDetails.worked) {
              refusedButWorkedTotal += hours;
            }
            
            total += hours;
          });
        }
      });
      
      // Optional: Log refused but worked hours for auditing
      if (refusedButWorkedTotal > 0) {
        console.log(`Person ${personId} has ${refusedButWorkedTotal}h from refused-but-worked shifts`);
      }
      
      return total;
    }

    // Get chargeable hours for a specific date from shifts
    function getShiftHoursForDate(personId, dateKey){
      const currentWeekendKey = getCurrentWeekendKey();
      const personShifts = getPersonShifts(personId, currentWeekendKey);
      const shift = getShiftForDate(personShifts, dateKey);
      
      if (shift) {
        const shiftDef = SHIFT_DEFINITIONS[shift.shiftCode];
        return shiftDef.chargeableHours;
      }
      
      return 0;
    }

    // --- Enhanced demo data seeding (adds 25 people with strategic hour distribution) ---
    function seedDemoData(){
      if (!confirm('Add 25 demo people with varied hours (0-100+ range) for comprehensive testing?')) return;
      
      const first = ['Alex','Jordan','Taylor','Morgan','Riley','Casey','Avery','Jamie','Cameron','Skyler','Quinn','Reese','Parker','Rowan','Elliot','Sage','Hayden','Dakota','Emerson','Kai','Logan','Sydney','Charlie','Sam','Devin','Remy','Arden','Blake','Drew','Jesse'];
      const last = ['Rivera','Lopez','Nguyen','Patel','Kim','Singh','Chen','Hernandez','Garcia','Martinez','Brown','Wilson','Clark','Lewis','Young','Diaz','Allen','King','Wright','Scott','Green','Baker','Hill','Adams','Nelson'];
      const pick = (arr) => arr[Math.floor(Math.random()*arr.length)];
      const nameSet = new Set(state.items.map(x => x.name.toLowerCase()));
      const mkList = () => String(Math.floor(100 + Math.random()*900));

      // Strategic hour targets to create good distribution for testing
      // Range from 0 (newcomers) to 100+ (veterans) with varied levels
      const hourTargets = [
        0, 2, 4, 6, 8,              // Newcomers/minimal (5 people)
        12, 16, 20, 24, 28,         // Light workers (5 people)
        32, 36, 40, 44, 48,         // Moderate workers (5 people) 
        52, 56, 60, 64, 68,         // Heavy workers (5 people)
        72, 76, 80, 88, 96          // Veterans/maximum (5 people)
      ];

      // Hour distribution patterns (realistic weekend scenarios)
      const hourPatterns = [
        // Newcomers: minimal/sporadic hours
        [0, 0, 0, 0], [0, 0, 2, 0], [0, 4, 0, 0], [2, 0, 4, 0], [0, 8, 0, 0],
        // Light workers: 1-2 shifts per weekend
        [8, 4, 0, 0], [0, 8, 8, 0], [8, 0, 12, 0], [0, 8, 16, 0], [8, 8, 12, 0],
        // Moderate workers: consistent 2-3 shifts
        [8, 8, 16, 0], [8, 8, 8, 8], [16, 8, 8, 0], [8, 16, 8, 8], [16, 8, 16, 8],
        // Heavy workers: 3-4 shifts regularly
        [16, 8, 8, 16], [8, 16, 16, 8], [16, 16, 8, 8], [8, 16, 16, 16], [16, 16, 16, 8],
        // Veterans: maximum hours, often 4+ shifts
        [16, 16, 16, 16], [16, 16, 8, 24], [8, 16, 16, 24], [16, 16, 24, 16], [24, 16, 16, 24]
      ];

      // Manual adjustments for variety (mostly positive to avoid negative totals)
      const adjustmentOptions = [0, 0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 12];

      const people = [];
      for (let i=0; i<25; i++){
        let nm = `${pick(first)} ${pick(last)}`;
        let tries=0; while (nameSet.has(nm.toLowerCase()) && tries++ < 50){ nm = `${pick(first)} ${pick(last)}`; }
        nameSet.add(nm.toLowerCase());
        people.push({ 
          id: uid(), 
          name: nm, 
          lisNumber: mkList(), 
          createdAt: new Date().toISOString(),
          _hourTarget: hourTargets[i], // For reference
          _pattern: hourPatterns[i]    // For reference
        });
      }

      // Append to items
      state.items = state.items.concat(people);
      save();

      // Create strategic hour distribution
      const wk = getWeekendColumns(state.viewYear, state.viewMonth1);
      const keys = []; wk.forEach(w => w.days.forEach(d => keys.push(dateKey(d.date))));
      
      people.forEach((p, index) => {
        if (!state.hours[p.id]) state.hours[p.id] = {};
        
        // Use the strategic pattern for this person
        const pattern = hourPatterns[index];
        const target = hourTargets[index];
        
        // Distribute hours across available weekend days
        keys.forEach((k, dayIndex) => {
          if (dayIndex < pattern.length && pattern[dayIndex] > 0) {
            // Add some random variation (±25%) to make it more realistic
            const baseHours = pattern[dayIndex];
            const variation = baseHours * 0.25 * (Math.random() - 0.5);
            const finalHours = Math.max(0, Math.round((baseHours + variation) * 4) / 4); // Quarter-hour precision
            if (finalHours > 0) {
              state.hours[p.id][k] = finalHours;
            }
          }
        });
        
        // Add strategic manual adjustments to hit target totals
        const currentTotal = Object.values(state.hours[p.id] || {}).reduce((sum, h) => sum + h, 0);
        const targetAdjustment = target - currentTotal;
        
        // Only use positive adjustments or small negative ones that won't make total negative
        const safeAdjustmentOptions = adjustmentOptions.filter(adj => {
          const resultTotal = currentTotal + adj;
          return resultTotal >= 0; // Ensure total never goes negative
        });
        
        const randomAdjustment = safeAdjustmentOptions.length > 0 
          ? safeAdjustmentOptions[Math.floor(Math.random() * safeAdjustmentOptions.length)]
          : 0;
        
        // Calculate final adjustment, ensuring total stays positive
        let finalAdjustment = Math.round((targetAdjustment + randomAdjustment) * 4) / 4;
        
        // Final safety check: ensure total hours never go negative
        const projectedTotal = currentTotal + finalAdjustment;
        if (projectedTotal < 0) {
          finalAdjustment = -currentTotal; // At worst, bring to 0, never negative
        }
        
        if (Math.abs(finalAdjustment) > 0.25) {
          state.adj[p.id] = (state.adj[p.id] || 0) + finalAdjustment;
        }
        
        // bump last-change for ranking
        if (typeof bumpLastChange === 'function') bumpLastChange(p.id);
      });
      
      saveHours(); saveAdj();
      
      console.log('🎯 Enhanced Demo Data Created:');
      console.log(`   - 25 people with strategic hour distribution (0-100+ range)`);
      console.log(`   - Hour targets: [${hourTargets.slice(0,5).join(',')}...${hourTargets.slice(-5).join(',')}]`);
      console.log(`   - Available weekend dates: ${keys.length} days`);
      console.log(`   - Ready for comprehensive feature testing!`);
      
      render();
    }
    // Update only one row's day inputs from state (no re-render of other rows)
    function updateRowFromState(personId){
      const weekends = getWeekendColumns(state.viewYear, state.viewMonth1);
      weekends.forEach(w => w.days.forEach(day => {
        const dk = dateKey(day.date);
        const inp = document.querySelector(`input[type="number"][data-person="${personId}"][data-date="${dk}"]`);
        if (inp){
          const v = getHours(personId, dk);
          inp.value = v == null ? '' : displayHours(v);
        }
      }));
      // Also refresh the row total to include extra
      updateTotalsFor(personId);
    }
    // dateKey: format date in local time as YYYY-MM-DD
    function dateKey(d){
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }

    // Hours store accessors
    function getHours(personId, dk){
      const p = state.hours[personId];
      if (!p) return null;
      const v = p[dk];
      return (typeof v === 'number' && !Number.isNaN(v)) ? v : null;
    }
    function setHours(personId, dk, num){
      if (!state.hours[personId]) state.hours[personId] = {};
      if (num == null || Number.isNaN(num) || String(num) === ''){ delete state.hours[personId][dk]; }
      else { state.hours[personId][dk] = Number(num); }
      saveHours();
    }

    // === Weekend Detection Utilities ===
    // Get the current weekend (Friday-Monday) for canvas operations
    // Special logic: Wednesday canvasses for the UPCOMING weekend (Fri-Mon)
    function getCurrentWeekend(){
      const today = new Date();
      const dayOfWeek = today.getDay(); // 0=Sun, 1=Mon, ..., 5=Fri, 6=Sat
      
      // Find the Friday that starts the current weekend
      // Updated logic: After Monday, we start working for the NEXT weekend
      let friday;
      if (dayOfWeek === 0) { // Sunday
        friday = new Date(today);
        friday.setDate(friday.getDate() - 2); // Go back to Friday
      } else if (dayOfWeek === 1) { // Monday
        friday = new Date(today);
        friday.setDate(friday.getDate() - 3); // Go back to Friday
      } else if (dayOfWeek === 2) { // Tuesday - Working for UPCOMING weekend
        friday = new Date(today);
        friday.setDate(friday.getDate() + 3); // Go forward to upcoming Friday
      } else if (dayOfWeek === 3) { // Wednesday - Working for UPCOMING weekend
        friday = new Date(today);
        friday.setDate(friday.getDate() + 2); // Go forward to upcoming Friday
      } else if (dayOfWeek === 4) { // Thursday - Working for UPCOMING weekend
        friday = new Date(today);
        friday.setDate(friday.getDate() + 1); // Go forward to upcoming Friday
      } else if (dayOfWeek === 5) { // Friday
        friday = new Date(today); // Today is Friday
      } else { // Saturday (dayOfWeek === 6)
        friday = new Date(today);
        friday.setDate(friday.getDate() - 1); // Go back to Friday
      }
      
      const monday = new Date(friday);
      monday.setDate(monday.getDate() + 3);
      
      return { friday, monday };
    }

    // Generate a unique key for a weekend period (uses Friday's date)
    function getWeekendKey(fridayDate){
      return dateKey(fridayDate); // YYYY-MM-DD format using Friday
    }

    // Get the current weekend key
    function getCurrentWeekendKey(){
      const weekend = getCurrentWeekend();
      return getWeekendKey(weekend.friday);
    }

    // Get the previous weekend (for reference)
    function getPreviousWeekend(){
      const current = getCurrentWeekend();
      const previousFriday = new Date(current.friday);
      previousFriday.setDate(previousFriday.getDate() - 7);
      
      const previousMonday = new Date(previousFriday);
      previousMonday.setDate(previousMonday.getDate() + 3);
      
      return { friday: previousFriday, monday: previousMonday };
    }

    // Get the previous weekend key
    function getPreviousWeekendKey(){
      const previousWeekend = getPreviousWeekend();
      return getWeekendKey(previousWeekend.friday);
    }

    // Get the weekend for the month currently being viewed in the table
    function getViewedWeekend(){
      // Get the first Friday of the viewed month
      const weekends = getWeekendColumns(state.viewYear, state.viewMonth1);
      if (weekends.length > 0) {
        // Use the first weekend of the viewed month
        const firstWeekend = weekends[0];
        return {
          friday: firstWeekend.friday,
          monday: firstWeekend.monday
        };
      }
      
      // Fallback to current weekend if no weekends in viewed month
      return getCurrentWeekend();
    }
    
    // Get the viewed weekend key (for the month being displayed in table)
    function getViewedWeekendKey(){
      const weekend = getViewedWeekend();
      return getWeekendKey(weekend.friday);
    }

    // WeekendCol type and generator
    // type WeekendCol = {
    //   friday: Date;
    //   monday: Date;
    //   label: string; // "Fri MMM D – Mon MMM D"
    //   days: { date: Date; dowShort: 'Fri'|'Sat'|'Sun'|'Mon'; dateLabel: string }[]
    // }
    function getWeekendColumns(year, month1Based){
      const monthIdx = month1Based - 1; // JS Date month is 0-based
      // Find first Friday of the month (0=Sun..6=Sat; 5=Fri)
      const first = new Date(year, monthIdx, 1);
      const delta = (5 - first.getDay() + 7) % 7;
      let fri = new Date(year, monthIdx, 1 + delta);
      
      const cols = [];
      // Include weekend if Friday is in the current month (even if Monday spills over)
      while (fri.getMonth() === monthIdx && fri.getDate() <= 31){
        const sat = new Date(fri); sat.setDate(sat.getDate()+1);
        const sun = new Date(fri); sun.setDate(sun.getDate()+2);
        const mon = new Date(fri); mon.setDate(mon.getDate()+3);
        
        
        const label = `Fri ${fmtMonthDay(fri)} \u2013 Mon ${fmtMonthDay(mon)}`;
        cols.push({
          friday: new Date(fri),
          monday: new Date(mon),
          label,
          days: [
            { date: new Date(fri), dowShort:'Fri', dateLabel: dayShort(fri) },
            { date: new Date(sat), dowShort:'Sat', dateLabel: dayShort(sat) },
            { date: new Date(sun), dowShort:'Sun', dateLabel: dayShort(sun) },
            { date: new Date(mon), dowShort:'Mon', dateLabel: dayShort(mon) },
          ]
        });
        fri.setDate(fri.getDate()+7);
      }
      return cols;
    }
    function fmtMonthDay(d){
      const m = d.toLocaleString(undefined, { month:'short' });
      return `${m} ${d.getDate()}`;
    }
    function dayShort(d){ return `${d.getDate()}`; }

    // Event wiring
    el.form.addEventListener('submit', (e) => { e.preventDefault(); upsertItem(el.name.value, el.lisNumber.value, el.initialHours.value); });
    el.cancelEditBtn.addEventListener('click', () => clearForm());
    el.search.addEventListener('input', () => { state.filter = el.search.value; render(); });
    el.clearAll.addEventListener('click', clearAll);
    el.exportCsv.addEventListener('click', exportCsv);
    el.exportJson.addEventListener('click', exportJson);
    el.importFile.addEventListener('change', (e) => { const f = e.target.files?.[0]; if (f) importFile(f).finally(() => { e.target.value=''; }); });
    // Import text button triggers hidden file input (UI only)
    const importBtn = document.getElementById('importTextBtn');
    if (importBtn) importBtn.addEventListener('click', () => document.getElementById('importFile')?.click());
    // Demo data button: add 25 fake rows + hours
    const demoBtn = document.getElementById('seedDemoBtn');
    if (demoBtn) demoBtn.addEventListener('click', seedDemoData);
    // Migration button: migrate old hours to new shift system
    if (el.migrateHoursBtn) el.migrateHoursBtn.addEventListener('click', () => {
      const result = migrateOldHoursToShifts();
      
      if (result.success) {
        if (result.alreadyDone) {
          alert('Migration already completed. Hours are already in the new shift system.');
        } else {
          alert(result.message + '\n\nThe page will now refresh to show the migrated hours.');
          // Refresh the page to show the migrated hours
          window.location.reload();
        }
      } else {
        alert('Migration failed: ' + result.message);
      }
    });
    // Reset all button: clear everything including corrupted data
    const resetBtn = document.getElementById('resetAllBtn');
    if (resetBtn) resetBtn.addEventListener('click', () => {
      if (!confirm('This will DELETE ALL DATA and reset everything. Continue?')) return;
      // Clear all localStorage keys related to this app
      const keysToRemove = [];
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && (key.startsWith('pass-list-') || key.startsWith('ot_') || key === STORAGE_KEY || key === HOURS_KEY || key === ADJ_KEY)) {
          keysToRemove.push(key);
        }
      }
      keysToRemove.forEach(k => localStorage.removeItem(k));
      // Reset state
      state.items = [];
      state.hours = {};
      state.adj = {};
      state.excluded = {};
      state.shifts = {};
      state.filter = '';
      clearForm();
      render();
      alert('All data has been reset.');
    });
    // Collapsible Add/Edit toggle (visual only)
    if (el.entryToggle && el.entryCard) el.entryToggle.addEventListener('click', () => {
      const cur = el.entryCard.getAttribute('data-collapsed') === 'true';
      el.entryCard.setAttribute('data-collapsed', cur ? 'false' : 'true');
    });

    el.tbody.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const id = btn.getAttribute('data-id');
      const action = btn.getAttribute('data-action');
      if (action === 'edit') setEditing(id);
      if (action === 'delete') deleteItem(id);
    });

    // Table interactions: inputs and shift selection
    el.tbody.addEventListener('input', (e) => {
      const t = e.target;
      // Handle shift-based hour inputs
      if (t && t.matches('input[type="number"][data-person][data-shift]')){
        const id = t.getAttribute('data-person');
        const shiftCode = t.getAttribute('data-shift');
        const weekendKey = t.getAttribute('data-weekend');
        const num = t.value === '' ? null : Number(t.value);
        setShiftHours(id, shiftCode, weekendKey, num);
        updateTotalsFor(id);
        bumpLastChange(id);
        return;
      }
      // Handle legacy date-based hour inputs (for backward compatibility)
      if (t && t.matches('input[type="number"][data-person][data-date]')){
        const id = t.getAttribute('data-person');
        const dk = t.getAttribute('data-date');
        const num = t.value === '' ? null : Number(t.value);
        setHours(id, dk, num);
        updateTotalsFor(id);
        bumpLastChange(id);
        return;
      }
      // Row total live typing: no-op until blur/change (we interpret the typed value as ManualAdj)
    });

    // Handle shift selection changes
    el.tbody.addEventListener('change', (e) => {
      const t = e.target;
      if (t && t.matches('select.shift-selector[data-person][data-weekend]')) {
        const personId = t.getAttribute('data-person');
        const weekendKey = t.getAttribute('data-weekend');
        const shiftCode = t.value;
        
        if (shiftCode) {
          if (assignShift(personId, shiftCode, weekendKey)) {
            // Update the display
            render();
            bumpLastChange(personId);
          } else {
            // Assignment failed, reset selector
            t.value = '';
          }
        }
        return;
      }
    });

    // Handle shift removal
    el.tbody.addEventListener('click', (e) => {
      const btn = e.target.closest('button.remove-shift');
      if (btn) {
        const personId = btn.getAttribute('data-person');
        const shiftCode = btn.getAttribute('data-shift');
        const weekendKey = btn.getAttribute('data-weekend');
        
        if (removeShift(personId, shiftCode, weekendKey)) {
          render();
        }
        return;
      }
    });
    // Select-all on focus for row total inputs
    el.tbody.addEventListener('focusin', (e) => {
      const t = e.target;
      if (t && t.matches('input.row-total-input[data-person]')){
        // Defer to ensure selection after focus
        setTimeout(() => { try { t.select(); } catch(_){} }, 0);
      }
    });
    // Normalize on blur/change: clamp 0..24 and round to nearest 0.25
    function handleNormalize(e){
      const t = e.target;
      // Handle shift-based hour inputs
      if (t && t.matches('input[type="number"][data-person][data-shift]')){
        const id = t.getAttribute('data-person');
        const shiftCode = t.getAttribute('data-shift');
        const weekendKey = t.getAttribute('data-weekend');
        const n = normalizeHours(t.value);
        setShiftHours(id, shiftCode, weekendKey, n);
        t.value = displayHours(n);
        updateTotalsFor(id);
        bumpLastChange(id);
        return;
      }
      // Handle legacy date-based hour inputs (for backward compatibility)
      if (t && t.matches('input[type="number"][data-person][data-date]')){
        const id = t.getAttribute('data-person');
        const dk = t.getAttribute('data-date');
        const n = normalizeHours(t.value);
        setHours(id, dk, n);
        t.value = displayHours(n);
        updateTotalsFor(id);
        bumpLastChange(id);
        return;
      }
      if (t && t.matches('input.row-total-input[data-person]')){
        const id = t.getAttribute('data-person');
        const desiredTotal = clampTotal(normalizeQuarter(Number(t.value) || 0));
        
        // Calculate current base sum from day hours
        const currentBaseSum = baseSum(id);
        
        console.log(`Row total edited for person ${id}:`);
        console.log(`- Desired total: ${desiredTotal}`);
        console.log(`- Current base sum: ${currentBaseSum}`);
        
        // Calculate the adjustment needed to reach desired total
        // adjustment = desiredTotal - baseSum
        const requiredAdjustment = desiredTotal - currentBaseSum;
        
        console.log(`- Required adjustment: ${requiredAdjustment}`);
        
        // Store the adjustment (can be positive or negative)
        state.adj[id] = requiredAdjustment;
        saveAdj();
        
        console.log(`- Stored adjustment: ${state.adj[id]}`);
        
        // Update the display to show the actual calculated total
        updateTotalsFor(id);
        bumpLastChange(id);
      }
    }
    el.tbody.addEventListener('blur', handleNormalize, true);
    el.tbody.addEventListener('change', handleNormalize);
    
    // Handle refused-worked checkbox changes
    el.tbody.addEventListener('change', (e) => {
      const checkbox = e.target;
      if (checkbox && checkbox.matches('input.refused-worked-checkbox[data-person][data-shift]')) {
        const personId = checkbox.getAttribute('data-person');
        const shiftCode = checkbox.getAttribute('data-shift');
        const weekendKey = checkbox.getAttribute('data-weekend');
        const isWorked = checkbox.checked;
        
        if (personId && shiftCode && weekendKey) {
          // Update the refusal record to mark as worked/not worked
          const refusalDetails = getShiftRefusalDetails(personId, shiftCode, weekendKey);
          if (refusalDetails) {
            const wasWorked = refusalDetails.worked; // Track previous state
            refusalDetails.worked = isWorked;
            
            if (isWorked) {
              // When marking as worked, use the current hours in the input field
              const hourInput = checkbox.closest('td').querySelector('input[type="number"]');
              const actualHours = hourInput ? (hourInput.value === '' ? 0 : Number(hourInput.value)) : 0;
              refusalDetails.actualHours = actualHours;
              
              // Add hours to main table if this wasn't already marked as worked
              if (!wasWorked) {
                const shift = SHIFT_DEFINITIONS[shiftCode];
                if (shift) {
                  const shiftData = { shiftCode };
                  addHoursForShift(personId, shiftData, weekendKey);
                }
              }
            } else {
              refusalDetails.actualHours = 0;
              
              // Remove hours from main table if this was previously marked as worked
              if (wasWorked) {
                const shift = SHIFT_DEFINITIONS[shiftCode];
                if (shift) {
                  const shiftData = { shiftCode };
                  removeHoursForShift(personId, shiftData, weekendKey);
                }
              }
            }
            saveRefusals();
            
            // Re-render the table to update styling
            render();
          }
        }
      }
    });
    
    // Right-click context menu for shift refusals
    el.tbody.addEventListener('contextmenu', (e) => {
      const input = e.target.closest('input[type="number"][data-shift]');
      if (!input) return;
      
      e.preventDefault(); // Prevent default context menu
      
      const personId = input.getAttribute('data-person');
      const shiftCode = input.getAttribute('data-shift');
      const weekendKey = input.getAttribute('data-weekend');
      
      if (!personId || !shiftCode || !weekendKey) return;
      
      const isRefused = getShiftRefusal(personId, shiftCode, weekendKey);
      const currentHours = getShiftHours(personId, shiftCode, weekendKey);
      
      // Create context menu
      const menu = document.createElement('div');
      menu.className = 'context-menu';
      menu.innerHTML = `
        <div class="context-menu-item" data-action="toggle-refusal">
          ${isRefused ? '✓ Remove Refusal' : 'Mark as Refusal'}
        </div>
        ${currentHours > 0 ? '<div class="context-menu-item" data-action="clear-hours">Clear Hours</div>' : ''}
        <div class="context-menu-item" data-action="cancel">Cancel</div>
      `;
      
      // Position menu at cursor
      menu.style.position = 'fixed';
      menu.style.left = e.pageX + 'px';
      menu.style.top = e.pageY + 'px';
      menu.style.zIndex = '1000';
      
      document.body.appendChild(menu);
      
      // Handle menu clicks
      menu.addEventListener('click', (menuEvent) => {
        const action = menuEvent.target.getAttribute('data-action');
        
        if (action === 'toggle-refusal') {
          const newRefusalStatus = !isRefused;
          setShiftRefusal(personId, shiftCode, weekendKey, newRefusalStatus);
          updateShiftWorkedStatus(personId, shiftCode, weekendKey, newRefusalStatus);
          render(); // Refresh to show visual changes
        } else if (action === 'clear-hours') {
          setShiftHours(personId, shiftCode, weekendKey, 0);
          clearShiftRefusal(personId, shiftCode, weekendKey);
          updateShiftWorkedStatus(personId, shiftCode, weekendKey, false); // Clear refusal, so they worked it
          render(); // Refresh to show changes
        }
        
        // Remove menu
        menu.remove();
      });
      
      // Remove menu on click outside
      setTimeout(() => {
        document.addEventListener('click', function removeMenu() {
          menu.remove();
          document.removeEventListener('click', removeMenu);
        });
      }, 10);
    });

    // Month switcher
    el.monthPicker.addEventListener('change', () => {
      const v = el.monthPicker.value; // YYYY-MM
      const [y, m] = v.split('-').map(Number);
      if (y && m){ state.viewYear = y; state.viewMonth1 = m; render(); }
    });
    // Who's Next search
    el.wnSearch.addEventListener('input', () => { state.wnQuery = el.wnSearch.value.toLowerCase(); renderWhosNext(); });
    
    
    // Location configuration
    if (el.updateLocationBtn) {
      el.updateLocationBtn.addEventListener('click', () => {
        const newCount = parseInt(el.locationCountInput.value) || DEFAULT_LOCATION_COUNT;
        const oldCapacity = getTotalWeekendCapacity();
        updateLocationCount(newCount);
        const newCapacity = getTotalWeekendCapacity();
        const shiftCapacity = getShiftCapacity('any');
        
        const message = `Location count updated to ${state.locationCount}!\n\n` +
                       `Per-shift capacity: ${shiftCapacity} people (${state.locationCount} locations × 2 people each)\n` +
                       `Total weekend capacity: ${newCapacity} people (was ${oldCapacity})\n\n` +
                       `Each shift can now accommodate ${shiftCapacity} people across ${state.locationCount} location(s).`;
        
        alert(message);
      });
    }
    
    // Initialize location display
    function initializeLocationDisplay() {
      if (el.locationCountInput) {
        el.locationCountInput.value = state.locationCount;
      }
      if (el.shiftCapacity) {
        el.shiftCapacity.textContent = `${getShiftCapacity('any')} people`;
      }
      if (el.totalCapacity) {
        el.totalCapacity.textContent = `${getTotalWeekendCapacity()} people`;
      }
    }

    // Who's Next button clicks (Assign/Done/Not Here) and shift chip clicks
    el.wnList.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      
      e.stopPropagation(); // Prevent triggering row click
      
      const personId = btn.getAttribute('data-person-id');
      
      // Handle Accept OT button click
      if (btn.getAttribute('data-action') === 'accept-ot') {
        const shiftCode = btn.getAttribute('data-shift-code');
        const weekendKey = btn.getAttribute('data-weekend-key');
        
        if (personId && shiftCode && weekendKey && !btn.disabled) {
          // Use bottom sheet confirmation on mobile, direct handler on desktop
          if (window.innerWidth <= 768) {
            handleAcceptOTWithConfirmation(personId, shiftCode, weekendKey, btn);
          } else {
            handleAcceptOT(personId, shiftCode, weekendKey, btn);
          }
        }
        return;
      }
      
      // Handle Refusal button click
      if (btn.getAttribute('data-action') === 'refuse') {
        const shiftCode = btn.getAttribute('data-shift-code');
        const weekendKey = btn.getAttribute('data-weekend-key');
        
        if (personId && shiftCode && weekendKey && !btn.disabled) {
          // Use bottom sheet confirmation on mobile, direct handler on desktop
          if (window.innerWidth <= 768) {
            handleRefuseWithConfirmation(personId, shiftCode, weekendKey, btn);
          } else {
            handleRefusal(personId, shiftCode, weekendKey, btn);
          }
        }
        return;
      }
      
      // Handle shift assignment (legacy - will be deprecated)
      if (btn.classList.contains('assign-shift')) {
        const shiftCode = btn.getAttribute('data-shift');
        const weekendKey = btn.getAttribute('data-weekend');
        
        console.log('🔵 SHIFT ASSIGNMENT BUTTON CLICKED');
        console.log(`   Person ID: ${personId}`);
        console.log(`   Shift Code: ${shiftCode}`);
        console.log(`   Weekend Key: ${weekendKey}`);
        console.log(`   Current Weekend Key: ${getCurrentWeekendKey()}`);
        
        if (personId && shiftCode && weekendKey) {
          console.log('🟡 Calling assignShift...');
          if (assignShift(personId, shiftCode, weekendKey)) {
            console.log('🎉 SHIFT ASSIGNMENT SUCCESSFUL - Updating UI');
            const person = state.items.find(p => p.id === personId);
            const shiftDef = SHIFT_DEFINITIONS[shiftCode];
            const newAssignedCount = getShiftAssignedCount(shiftCode, weekendKey);
            const capacity = getShiftCapacity(shiftCode);
            const capacityMsg = newAssignedCount >= capacity ? ' - SHIFT NOW FULL' : ` (${newAssignedCount}/${capacity} filled)`;
            console.log(`${person?.name || 'Person'} assigned to ${shiftDef.name}${capacityMsg}`);
            console.log('🔄 Calling render() to update table...');
            render(); // Update both table and Who's Next list
          }
        }
        return;
      }
      
      // Handle shift refusal
      if (btn.classList.contains('refuse-shift')) {
        const shiftCode = btn.getAttribute('data-shift');
        const weekendKey = btn.getAttribute('data-weekend');
        
        if (personId && shiftCode && weekendKey) {
          const person = state.items.find(p => p.id === personId);
          const shiftDef = SHIFT_DEFINITIONS[shiftCode];
          const assignedCount = getShiftAssignedCount(shiftCode, weekendKey);
          const capacity = getShiftCapacity(shiftCode);
          const capacityInfo = `(${assignedCount}/${capacity} filled)`;
          
          if (confirm(`${person?.name || 'Person'} refuses ${shiftDef?.name || 'shift'} ${capacityInfo}?`)) {
            refuseShift(personId, shiftCode, weekendKey);
            console.log(`${person?.name || 'Person'} refused ${shiftDef?.name || 'shift'} ${capacityInfo}`);
            render(); // Update both table and Who's Next list
          }
        }
        return;
      }
      
      // Handle shift un-refusal
      if (btn.classList.contains('unrefuse-shift')) {
        const shiftCode = btn.getAttribute('data-shift');
        const weekendKey = btn.getAttribute('data-weekend');
        
        if (personId && shiftCode && weekendKey) {
          const person = state.items.find(p => p.id === personId);
          const shiftDef = SHIFT_DEFINITIONS[shiftCode];
          unrefuseShift(personId, shiftCode, weekendKey);
          console.log(`${person?.name || 'Person'} un-refused ${shiftDef?.name || 'shift'}`);
          render(); // Update both table and Who's Next list
        }
        return;
      }
      
      // Handle shift reset
      if (btn.classList.contains('reset-shift')) {
        const shiftCode = btn.getAttribute('data-shift');
        const weekendKey = btn.getAttribute('data-weekend');
        
        if (personId && shiftCode && weekendKey) {
          const person = state.items.find(p => p.id === personId);
          const shiftDef = SHIFT_DEFINITIONS[shiftCode];
          
          // Determine what we're resetting for better confirmation message
          const isAssigned = getPersonShifts(personId, weekendKey)?.shifts.some(s => s.shiftCode === shiftCode);
          const refusalDetails = getShiftRefusalDetails(personId, shiftCode, weekendKey);
          const isRefused = refusalDetails?.refused;
          const isWorked = refusalDetails?.worked;
          
          let resetType = '';
          if (isAssigned) resetType = 'assignment';
          else if (isRefused && isWorked) resetType = 'worked refusal';
          else if (isRefused) resetType = 'refusal';
          
          const confirmMessage = resetType 
            ? `Reset ${person?.name || 'Person'}'s ${resetType} for ${shiftDef?.name || 'shift'}?\n\nThis will remove the ${resetType} and any associated hours.`
            : `Reset ${person?.name || 'Person'}'s ${shiftDef?.name || 'shift'} data?\n\nThis will clean up any assignments, refusals, and hours.`;
          
          if (confirm(confirmMessage)) {
            const result = resetPersonShift(personId, shiftCode, weekendKey);
            
            if (result.success) {
              const actionsText = result.actions.join(' and ');
              console.log(`Reset ${person?.name || 'Person'}'s ${shiftDef?.name || 'shift'} - removed: ${actionsText}`);
              render(); // Update both table and Who's Next list
            } else {
              console.log(`No data to reset for ${person?.name || 'Person'}'s ${shiftDef?.name || 'shift'}`);
            }
          }
        }
        return;
      }
      
      // Handle restore button
      if (btn.classList.contains('restore-person') && personId) {
        includePersonBack(personId);
        
        // Show feedback message
        const person = state.items.find(p => p.id === personId);
        const name = person ? person.name : 'Person';
        console.log(`${name} restored to Who's Next list`);
        
        // Optional: Add visual feedback
        btn.style.backgroundColor = 'var(--success)';
        setTimeout(() => {
          btn.style.backgroundColor = '';
        }, 300);
        return;
      }
      
      // Handle Not Here
      const action = btn.getAttribute('data-action');
      if (personId && action === 'nothere') {
        excludePerson(personId, action);
        
        // Show feedback message
        const person = state.items.find(p => p.id === personId);
        const name = person ? person.name : 'Person';
        const message = `${name} marked as Not Here for this weekend`;
        
        // Simple feedback - could be enhanced with a toast notification
        console.log(message);
        
        // Optional: Add visual feedback by briefly highlighting the button
        btn.style.opacity = '0.5';
        setTimeout(() => {
          btn.style.opacity = '';
        }, 300);
      }
    });

    // Build dynamic header for weekends
    function renderOvertimeHeader(weekends){
      // Row 1: fixed columns + weekend group headers + Row Total + Actions
      const row1 = [];
      row1.push('<tr class="thead-range">');
      // Sticky first three columns for better readability when scrolling
      row1.push('<th class="sortable col-list" scope="col" data-key="lisNumber" rowspan="2" title="List number for sorting">List # <span class="dir"></span></th>');
      row1.push('<th class="sortable col-name" scope="col" data-key="name" rowspan="2">Name <span class="dir"></span></th>');
      weekends.forEach(w => {
        row1.push(`<th class="th-group" scope="colgroup" colspan="5" title="${w.label}">${escapeHtml(w.label)}</th>`);
      });
      row1.push('<th class="right" scope="col" rowspan="2" title="Cumulative total hours across all months">Total Hours (All Time)</th>');
      row1.push('<th class="right th-actions" scope="col" rowspan="2">Actions</th>');
      row1.push('</tr>');

      // Row 2: shift column headers
      const row2 = [];
      row2.push('<tr class="thead-shifts">');
      weekends.forEach(w => {
        // Get the 5 shift definitions in order
        const shifts = [
          { key: 'shift1_fri_sat', name: 'Shift 1', time: 'Fri 10p-Sat 2p', title: 'Shift 1: Friday 10pm - Saturday 2pm (16h total, 8h chargeable)' },
          { key: 'shift2_sat_afternoon', name: 'Shift 2', time: 'Sat 2p-10p', title: 'Shift 2: Saturday 2pm - 10pm (8h overtime)' },
          { key: 'shift3_sat_night', name: 'Shift 3', time: 'Sat 10p-Sun 6a', title: 'Shift 3: Saturday 10pm - Sunday 6am (8h overtime)' },
          { key: 'shift4_sun_morning', name: 'Shift 4', time: 'Sun 6a-2p', title: 'Shift 4: Sunday 6am - 2pm (8h overtime)' },
          { key: 'shift5_2_to_finish', name: 'Shift 5', time: 'Sun 2p-Mon 6a', title: 'Shift 5: Sunday 2pm - Monday 6am (16h overtime, "2 to finish")' }
        ];
        
        shifts.forEach(shift => {
          // Calculate the relevant dates for this shift based on weekend dates
          let dateDisplay = '';
          const fri = w.days[0].date; // Friday
          const sat = w.days[1].date; // Saturday  
          const sun = w.days[2].date; // Sunday
          const mon = w.days[3].date; // Monday
          
          switch(shift.key) {
            case 'shift1_fri_sat':
              dateDisplay = `${fri.toLocaleString(undefined,{month:'short'})} ${fri.getDate()}-${sat.getDate()}`;
              break;
            case 'shift2_sat_afternoon':
              dateDisplay = `${sat.toLocaleString(undefined,{month:'short'})} ${sat.getDate()}`;
              break;
            case 'shift3_sat_night':
              dateDisplay = `${sat.toLocaleString(undefined,{month:'short'})} ${sat.getDate()}-${sun.getDate()}`;
              break;
            case 'shift4_sun_morning':
              dateDisplay = `${sun.toLocaleString(undefined,{month:'short'})} ${sun.getDate()}`;
              break;
            case 'shift5_2_to_finish':
              dateDisplay = `${sun.toLocaleString(undefined,{month:'short'})} ${sun.getDate()}-${mon.getDate()}`;
              break;
          }
          
          // Get capacity information for this shift
          const currentWeekendKey = getCurrentWeekendKey();
          const assignedCount = getShiftAssignedCount(shift.key, currentWeekendKey);
          const capacity = getShiftCapacity(shift.key);
          const capacityDisplay = `${assignedCount}/${capacity}`;
          const capacityClass = assignedCount >= capacity ? ' full' : assignedCount > 0 ? ' partial' : '';
          
          row2.push(`<th class="th-sub shift-col${capacityClass}" scope="col" data-shift="${shift.key}" title="${shift.title} - ${capacityDisplay} spots filled"><span class="header-cell"><span class="shift-name">${shift.name}</span><span class="shift-time">${shift.time}</span><span class="date">${dateDisplay}</span><span class="capacity-indicator">${capacityDisplay}</span></span></th>`);
        });
      });
      row2.push('</tr>');

      el.thead.innerHTML = row1.join('') + row2.join('');
      // Wire sorting clicks
      document.querySelectorAll('th.sortable').forEach(th => th.addEventListener('click', () => setSort(th.getAttribute('data-key'))));
    }

    // === Weekend Reset Detection ===
    // Check if we've moved to a new weekend since last visit
    function checkWeekendReset(){
      const currentWeekendKey = getCurrentWeekendKey();
      const lastWeekendKey = localStorage.getItem('wn_last_weekend_v1');
      
      if (lastWeekendKey && lastWeekendKey !== currentWeekendKey) {
        // We've moved to a new weekend - clear old exclusions and refusals
        cleanupOldExclusions();
        cleanupOldRefusals();
        console.log(`Weekend reset detected: ${lastWeekendKey} → ${currentWeekendKey}`);
      }
      
      // Update the stored weekend key
      localStorage.setItem('wn_last_weekend_v1', currentWeekendKey);
    }

    // Init
    state.items = load();
    state.hours = loadHours();
    state.adj = loadAdj();
    state.excluded = loadExclusions();
    state.shifts = loadShifts();
    state.refusals = loadRefusals();
    state.locationCount = loadLocationConfig();
    
    // Migrate existing shift data to include 'worked' field
    migrateShiftWorkedStatus();
    
    // Check for weekend transitions and cleanup old data
    checkWeekendReset();
    
    // Set month picker to current month
    const now = new Date();
    state.viewYear = now.getFullYear();
    state.viewMonth1 = now.getMonth() + 1;
    
    // Initialize location display
    initializeLocationDisplay();
    
    // === INSTANT UI UPDATE SYSTEM ===
    // Set up state listeners for instant UI updates without page refresh
    
    function setupInstantUpdates() {
      console.log('🚀 Setting up instant UI update system');
      
      // Subscribe to state changes
      subscribeToStateChanges((changeType, data) => {
        console.log(`🔄 Processing state change: ${changeType}`, data);
        
        switch (changeType) {
          case 'HOURS_UPDATED':
            handleHoursUpdate(data);
            break;
          case 'SHIFT_ASSIGNED':
            handleShiftAssignment(data);
            break;
          case 'SHIFT_REFUSED':
            handleShiftRefusal(data);
            break;
          case 'PERSON_EXCLUDED':
            handlePersonExclusion(data);
            break;
          case 'CAPACITY_CHANGED':
            handleCapacityChange(data);
            break;
          default:
            // For any other changes, do a selective update
            performSelectiveUpdate();
        }
      });
    }
    
    // Handle hours update without full page refresh
    function handleHoursUpdate(data) {
      console.log('⚡ Instant hours update:', data);
      
      // Update the specific cell in the main table
      const cell = document.querySelector(`[data-person="${data.personId}"][data-shift="${data.shiftId}"]`);
      if (cell) {
        const input = cell.querySelector('input');
        if (input) {
          const currentValue = parseFloat(input.value) || 0;
          const newValue = currentValue + data.hours;
          input.value = displayHours(newValue);
        }
      }
      
      // Update totals
      updatePersonTotalsInstantly(data.personId);
      
      // Re-rank Who's Next panel
      renderWhosNext();
    }
    
    // Handle shift assignment without full page refresh
    function handleShiftAssignment(data) {
      console.log('⚡ Instant shift assignment:', data);
      
      // Update shift capacity displays
      updateShiftCapacityDisplays();
      
      // Re-render Who's Next with new eligibility
      renderWhosNext();
      
      // Update weekend summary
      if (data.weekendKey) {
        renderWeekendSummary(data.weekendKey);
      }
    }
    
    // Handle shift refusal without full page refresh
    function handleShiftRefusal(data) {
      console.log('⚡ Instant shift refusal:', data);
      
      // Re-render Who's Next with updated options
      renderWhosNext();
      
      // Update weekend summary
      if (data.weekendKey) {
        renderWeekendSummary(data.weekendKey);
      }
    }
    
    // Handle person exclusion without full page refresh  
    function handlePersonExclusion(data) {
      console.log('⚡ Instant person exclusion:', data);
      
      // Re-render Who's Next to reflect exclusion
      renderWhosNext();
    }
    
    // Handle capacity changes without full page refresh
    function handleCapacityChange(data) {
      console.log('⚡ Instant capacity change:', data);
      
      // Update capacity displays
      updateShiftCapacityDisplays();
      
      // Re-render Who's Next with new availability
      renderWhosNext();
      
      // Update weekend summary  
      if (data.weekendKey) {
        renderWeekendSummary(data.weekendKey);
      }
    }
    
    // Update person totals instantly
    function updatePersonTotalsInstantly(personId) {
      const newTotal = effectiveTotal(personId); // Includes all hours + adjustments + refusal penalties
      
      // Update the row total input if visible
      const rowTotalInput = document.querySelector(`.row-total-input[data-person="${personId}"]`);
      if (rowTotalInput) {
        const displayValue = newTotal > 0 ? displayHours(newTotal) : '';
        if (rowTotalInput.value !== displayValue) {
          rowTotalInput.value = displayValue;
        }
      }
    }
    
    // Update shift capacity displays instantly
    function updateShiftCapacityDisplays() {
      // Update capacity indicators in table headers
      const capacityElements = document.querySelectorAll('.capacity-indicator');
      capacityElements.forEach(element => {
        const shiftHeader = element.closest('[data-shift]');
        if (shiftHeader) {
          const shiftId = shiftHeader.getAttribute('data-shift');
          if (shiftId) {
            const assigned = getShiftAssignedCount(shiftId);
            const capacity = getShiftCapacity(shiftId);
            element.textContent = `${assigned}/${capacity}`;
            
            // Update capacity class on header
            shiftHeader.classList.remove('full', 'partial');
            if (assigned >= capacity) {
              shiftHeader.classList.add('full');
            } else if (assigned > 0) {
              shiftHeader.classList.add('partial');
            }
          }
        }
      });
    }
    
    // Perform selective update for unknown changes
    function performSelectiveUpdate() {
      console.log('⚡ Performing selective update');
      
      // Only update dynamic parts, not the entire table structure
      renderWhosNext();
      
      const currentWeekendKey = getCurrentWeekendKey();
      renderWeekendSummary(currentWeekendKey);
      
      // Update capacity displays
      updateShiftCapacityDisplays();
      
      // Invalidate eligibility cache for next render
      invalidateEligibilityCache();
    }
    
    // Set up instant updates
    setupInstantUpdates();
    
    render();
    
    // Test function for weekend status (accessible from browser console)
    window.testWeekendStatus = function() {
      const today = new Date();
      const currentWeekend = getCurrentWeekend();
      const previousWeekend = getPreviousWeekend();
      
      console.log('🗓️  Today:', today.toLocaleDateString(), `(${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][today.getDay()]})`);
      console.log('📅 Current Weekend Key:', getCurrentWeekendKey());
      console.log('📅 Current Weekend:', {
        friday: currentWeekend.friday.toLocaleDateString(),
        monday: currentWeekend.monday.toLocaleDateString()
      });
      console.log('📅 Previous Weekend Key:', getPreviousWeekendKey());
      console.log('📅 Previous Weekend:', {
        friday: previousWeekend.friday.toLocaleDateString(),
        monday: previousWeekend.monday.toLocaleDateString()
      });
      console.log('📊 State.shifts keys:', Object.keys(state.shifts));
      console.log('🔄 Weekend Summary re-rendering...');
      renderWeekendSummary();
      console.log('✅ Weekend summary rendered');
    };

    // === MOBILE BOTTOM SHEET FUNCTIONALITY ===
    
    let currentBottomSheetAction = null;
    let currentBottomSheetData = null;

    function showBottomSheet(title, content, confirmText, confirmAction, data) {
      if (!window.innerWidth || window.innerWidth > 768) {
        // On desktop, just execute the action directly with a simple confirm
        if (confirm(title + '\n\n' + content)) {
          confirmAction(data);
        }
        return;
      }

      const backdrop = document.getElementById('bottomSheetBackdrop');
      const sheet = document.getElementById('bottomSheet');
      const titleEl = document.getElementById('bottomSheetTitle');
      const bodyEl = document.getElementById('bottomSheetBody');
      const confirmBtn = document.getElementById('bottomSheetConfirm');
      
      if (!backdrop || !sheet) return;

      titleEl.textContent = title;
      bodyEl.innerHTML = content;
      confirmBtn.textContent = confirmText;
      
      currentBottomSheetAction = confirmAction;
      currentBottomSheetData = data;
      
      // Show with animation
      backdrop.style.display = 'block';
      requestAnimationFrame(() => {
        backdrop.classList.add('show');
        sheet.classList.add('show');
      });
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }

    function hideBottomSheet() {
      const backdrop = document.getElementById('bottomSheetBackdrop');
      const sheet = document.getElementById('bottomSheet');
      
      if (!backdrop || !sheet) return;
      
      backdrop.classList.remove('show');
      sheet.classList.remove('show');
      
      setTimeout(() => {
        backdrop.style.display = 'none';
        currentBottomSheetAction = null;
        currentBottomSheetData = null;
        // Restore body scroll
        document.body.style.overflow = '';
      }, 300);
    }

    function confirmBottomSheetAction() {
      if (currentBottomSheetAction && currentBottomSheetData) {
        currentBottomSheetAction(currentBottomSheetData);
      }
      hideBottomSheet();
    }

    // Set up bottom sheet event listeners
    document.addEventListener('DOMContentLoaded', function() {
      const cancelBtn = document.getElementById('bottomSheetCancel');
      const confirmBtn = document.getElementById('bottomSheetConfirm');
      const closeBtn = document.getElementById('bottomSheetClose');
      const backdrop = document.getElementById('bottomSheetBackdrop');
      
      if (cancelBtn) cancelBtn.addEventListener('click', hideBottomSheet);
      if (confirmBtn) confirmBtn.addEventListener('click', confirmBottomSheetAction);
      if (closeBtn) closeBtn.addEventListener('click', hideBottomSheet);
      
      // Close on backdrop click
      if (backdrop) {
        backdrop.addEventListener('click', (e) => {
          if (e.target === backdrop) {
            hideBottomSheet();
          }
        });
      }
      
      // Close on escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          hideBottomSheet();
        }
      });
    });

    // === MOBILE TOAST FUNCTIONALITY ===
    
    function showToast(message, type = 'success', duration = 3000) {
      const container = document.getElementById('toastContainer');
      if (!container) return;
      
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      
      container.appendChild(toast);
      
      // Show toast
      requestAnimationFrame(() => {
        toast.classList.add('show');
      });
      
      // Auto-hide toast
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          if (container.contains(toast)) {
            container.removeChild(toast);
          }
        }, 300);
      }, duration);
    }

    // === ENHANCED ACCEPT/REFUSE HANDLERS FOR MOBILE ===
    
    // Enhanced Accept OT handler with bottom sheet confirmation
    async function handleAcceptOTWithConfirmation(personId, shiftCode, weekendKey, buttonElement) {
      const person = state.items.find(p => p.id === personId);
      const shift = SHIFT_DEFINITIONS[shiftCode];
      
      if (!person || !shift) return;
      
      const title = `Accept Overtime Shift`;
      const content = `
        <div style="text-align: center; margin: 16px 0;">
          <strong>${person.name}</strong>
          <div style="margin: 8px 0; color: var(--muted);">${person.lisNumber} • ${person.passNumber}</div>
        </div>
        <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin: 16px 0;">
          <div><strong>Shift:</strong> ${shift.name}</div>
          <div><strong>Hours:</strong> ${shift.chargeableHours}h</div>
          <div><strong>Weekend:</strong> ${new Date(weekendKey).toLocaleDateString()}</div>
        </div>
        <div style="color: var(--muted); font-size: 13px; text-align: center;">
          This will assign you to work this shift and add ${shift.chargeableHours} chargeable hours.
        </div>
      `;
      
      showBottomSheet(
        title, 
        content, 
        'Accept Shift',
        (data) => {
          handleAcceptOT(data.personId, data.shiftCode, data.weekendKey, data.buttonElement);
          showToast(`Accepted ${shift.shortDisplay} shift!`, 'success');
        },
        { personId, shiftCode, weekendKey, buttonElement }
      );
    }

    // Enhanced Refuse handler with bottom sheet confirmation
    async function handleRefuseWithConfirmation(personId, shiftCode, weekendKey, buttonElement) {
      const person = state.items.find(p => p.id === personId);
      const shift = SHIFT_DEFINITIONS[shiftCode];
      
      if (!person || !shift) return;
      
      const title = `Refuse Overtime Shift`;
      const content = `
        <div style="text-align: center; margin: 16px 0;">
          <strong>${person.name}</strong>
          <div style="margin: 8px 0; color: var(--muted);">${person.lisNumber} • ${person.passNumber}</div>
        </div>
        <div style="background: var(--bg); padding: 16px; border-radius: 8px; margin: 16px 0;">
          <div><strong>Shift:</strong> ${shift.name}</div>
          <div><strong>Hours:</strong> ${shift.chargeableHours}h</div>
          <div><strong>Weekend:</strong> ${new Date(weekendKey).toLocaleDateString()}</div>
        </div>
        <div style="color: var(--danger); font-size: 13px; text-align: center;">
          <strong>Warning:</strong> Refusing adds ${shift.chargeableHours} penalty hours to your total.
        </div>
      `;
      
      showBottomSheet(
        title, 
        content, 
        'Refuse Shift',
        (data) => {
          handleRefusal(data.personId, data.shiftCode, data.weekendKey, data.buttonElement);
          showToast(`Refused ${shift.shortDisplay} shift`, 'error');
        },
        { personId, shiftCode, weekendKey, buttonElement }
      );
    }
    
  </script>

  <!-- Bottom Sheet Modal for Mobile Confirmations -->
  <div id="bottomSheetBackdrop" class="bottom-sheet-backdrop">
    <div id="bottomSheet" class="bottom-sheet">
      <div class="bottom-sheet-header">
        <div class="bottom-sheet-handle"></div>
        <h3 id="bottomSheetTitle" class="bottom-sheet-title">Confirm Action</h3>
        <button id="bottomSheetClose" class="bottom-sheet-close" type="button" aria-label="Close">&times;</button>
      </div>
      <div id="bottomSheetBody" class="bottom-sheet-body">
        <!-- Content will be dynamically inserted here -->
      </div>
      <div id="bottomSheetActions" class="bottom-sheet-actions">
        <button id="bottomSheetCancel" class="secondary" type="button">Cancel</button>
        <button id="bottomSheetConfirm" class="primary" type="button">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Toast Container for Mobile Notifications -->
  <div id="toastContainer" class="toast-container"></div>

</body>
</html>
